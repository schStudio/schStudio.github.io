<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SCH</title>
    <description>苏灿灏的博客 大数据爱好者</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 03 Apr 2016 00:12:04 +0800</pubDate>
    <lastBuildDate>Sun, 03 Apr 2016 00:12:04 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>House Robber(II)(III)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#house-robber&quot; id=&quot;markdown-toc-house-robber&quot;&gt;House Robber&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#house-robber-ii&quot; id=&quot;markdown-toc-house-robber-ii&quot;&gt;House Robber II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#house-robber-iii&quot; id=&quot;markdown-toc-house-robber-iii&quot;&gt;House Robber III&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;house-robber&quot;&gt;House Robber&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;

  &lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int rob( int[] nums ) {
	// maxBroken : 前一次抢劫状态的最大值
    // maxUnbroken : 前一次非抢劫状态的最大值
    int maxBroken = 0, maxUnbroken = 0;
    for( int i = 0; i &amp;lt; nums.length; ++i ) {
        int t = maxBroken;
        maxBroken = Math.max( maxUnbroken+nums[i], maxBroken );
        maxUnbroken = Math.max( maxUnbroken, t );
    }
    return Math.max( maxBroken, maxUnbroken );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;当前最大值&lt;/code&gt;有2种情况:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;抢劫当前家庭后的最大值&lt;/code&gt; = max( &lt;code class=&quot;highlighter-rouge&quot;&gt;前一次非抢劫状态最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;当前值&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;前一次抢劫状态最大值&lt;/code&gt; )&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;不抢劫当前家庭的最大值&lt;/code&gt; = max( &lt;code class=&quot;highlighter-rouge&quot;&gt;前一次非抢劫状态最大值&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;前一次抢劫状态最大值&lt;/code&gt; )&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;最优子结构: &lt;code class=&quot;highlighter-rouge&quot;&gt;当前最大值&lt;/code&gt;依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;前一次最大值&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;重叠子问题: 求&lt;code class=&quot;highlighter-rouge&quot;&gt;1.&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2.&lt;/code&gt;的时候有一个重叠的子问题&lt;code class=&quot;highlighter-rouge&quot;&gt;前一次抢劫状态最大值&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;house-robber-ii&quot;&gt;House Robber II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This is an extension of House Robber.&lt;/p&gt;

  &lt;p&gt;After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.&lt;/p&gt;

  &lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int rob( int[] nums ) {
    if( nums.length == 0 ) return 0;
    // 抢劫第一户家庭
    int max1 = nums[0] + robHelper( nums, 2, nums.length-1 );
    // 不抢劫第一户家庭
    int max2 = robHelper( nums, 1, nums.length );
    return Math.max( max1, max2 );
}

public static int robHelper( int[] nums, int left, int right ) {
    // maxBroken : 前一次抢劫状态的最大值
    // maxUnbroken : 前一次非抢劫状态的最大值
    int maxBroken = 0, maxUnbroken = 0;
    for( int i = left; i &amp;lt; right; ++i ) {
        int t = maxBroken;
        maxBroken = Math.max( maxUnbroken+nums[i], maxBroken );
        maxUnbroken = Math.max( maxUnbroken, t );
    }
    return Math.max( maxBroken, maxUnbroken );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 同&lt;code class=&quot;highlighter-rouge&quot;&gt;House Robber&lt;/code&gt;相同, 在此基础上多了环的问题, 那么就需要考虑环对原本解决方案带来的影响: 环的问题归于头尾之间有影响关系, 那么我们可以分情况考虑: &lt;code class=&quot;highlighter-rouge&quot;&gt;抢劫第一户家庭&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;不抢劫第一户家庭&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;抢劫第一户家庭&lt;/code&gt;的话, 我们就肯定不能抢劫第二户家庭和最后一户家庭, 所以抢劫第[3…n-1]户家庭&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;不抢劫第一户家庭&lt;/code&gt;的话, 我们可以抢劫第[2…n]户家庭&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后只要考虑这2个情况的最大值即可&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是(n), 空间复杂度是(1)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;house-robber-iii&quot;&gt;House Robber III&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.&lt;/p&gt;

  &lt;p&gt;Determine the maximum amount of money the thief can rob tonight without alerting the police.&lt;/p&gt;

  &lt;p&gt;Example 1:&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      3
     / \
    2   3
     \   \ 
      3   1
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;p&gt;Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.&lt;/p&gt;

  &lt;p&gt;Example 2:&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      3
     / \
    4   5
   / \   \ 
  1   3   1
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;p&gt;Maximum amount of money the thief can rob = 4 + 5 = 9.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int rob( TreeNode root ) {
    return robHelper( root )[0];
}

public static int[] robHelper( TreeNode root ) {
    if( root == null ) return new int[]{ 0, 0, 0 };
    
    int[] robLeft = robHelper( root.left );
    int[] robRight = robHelper( root.right );
    
    // robRoot: 
    //        robRoot[0]: 抢劫最大值
    //        robRoot[1]: 左子树抢劫最大值
    //        robRoot[2]: 右子树抢劫最大值
    int[] robRoot = new int[3];
    robRoot[0] = Math.max( robLeft[0]+robRight[0], 
            robLeft[1]+robLeft[2]+robRight[1]+robRight[2]+root.val );
    robRoot[1] = robLeft[0];
    robRoot[2] = robRight[0];
    
    return robRoot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 一样是&lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;, 而且其特征更加明显:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最优子结构: &lt;code class=&quot;highlighter-rouge&quot;&gt;当前树最大值&lt;/code&gt; =  max( &lt;code class=&quot;highlighter-rouge&quot;&gt;左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;右子树最大值&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;左左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左右子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;右左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;右右子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;当前值&lt;/code&gt; )&lt;/li&gt;
  &lt;li&gt;重叠子问题: 求解&lt;code class=&quot;highlighter-rouge&quot;&gt;左子树最大值&lt;/code&gt;的时候需要子问题&lt;code class=&quot;highlighter-rouge&quot;&gt;左左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左右子树最大值&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;不抢当前节点: &lt;code class=&quot;highlighter-rouge&quot;&gt;左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;右子树最大值&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;抢劫当前节点: &lt;code class=&quot;highlighter-rouge&quot;&gt;左左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;左右子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;右左子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;右右子树最大值&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;当前值&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是(2^n), 空间复杂度是(n)&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/02/leetcode-house-robber(II)/</link>
        <guid isPermaLink="true">/2016/04/02/leetcode-house-robber(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>UniquePaths(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#uniquepaths&quot; id=&quot;markdown-toc-uniquepaths&quot;&gt;UniquePaths&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#uniquepaths-ii&quot; id=&quot;markdown-toc-uniquepaths-ii&quot;&gt;UniquePaths II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;uniquepaths&quot;&gt;UniquePaths&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;

  &lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;

  &lt;p&gt;How many possible unique paths are there?&lt;/p&gt;

  &lt;p&gt;Note: m and n will be at most 100.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2014/12/robot_maze.png&quot; alt=&quot;unique-path&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int uniquePaths( int m, int n ) {
    // dp[i][j]: 在[i][j]格子的所有可能Path
    int[][] dp = new int[m][n];
    // 起点位置, 竖线Path为1
    for( int i = 0; i &amp;lt; m; ++i )
        dp[i][0] = 1;
    // 起点位置, 横线Path为1
    for( int j = 0; j &amp;lt; n; ++j )
        dp[0][j] = 1;

    for( int i = 1; i &amp;lt; m; ++i )
        for( int j = 1; j &amp;lt; n; ++j )
            dp[i][j] = dp[i-1][j] + dp[i][j-1];

    return dp[m-1][n-1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;当前格子&lt;/code&gt;可以由&lt;code class=&quot;highlighter-rouge&quot;&gt;左边格子&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;上边格子&lt;/code&gt;的路径数目相加, 所以定义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;: 在第&lt;code class=&quot;highlighter-rouge&quot;&gt;[i][j]&lt;/code&gt;个格子的所有可能路径数&lt;/li&gt;
  &lt;li&gt;最优子结构: &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j]&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j-1]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;重叠子问题: &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j-1]&lt;/code&gt;都需要子问题&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j-1]&lt;/code&gt;的值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(mn), 空间复杂度是O(mn)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;uniquepaths-ii&quot;&gt;UniquePaths II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow up for “Unique Paths”:&lt;/p&gt;

  &lt;p&gt;Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;/p&gt;

  &lt;p&gt;An obstacle and empty space is marked as 1 and 0 respectively in the grid.&lt;/p&gt;

  &lt;p&gt;For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	[0,0,0],
  	[0,1,0],
  	[0,0,0]
]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;p&gt;The total number of unique paths is 2.&lt;/p&gt;

  &lt;p&gt;Note: &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; will be at most 100.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int uniquePaths( int[][] obstacleGrid ) {
    if( obstacleGrid.length == 0 ) return 0;

    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    // dp[i][j]: 在[i][j]格子的所有可能Path
    int[][] dp = new int[m][n];
    // 起点位置, 竖线Path为1, 遇到障碍之后的为0
    int i = 0;
    for( ; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0]==0; ++i )
        dp[i][0] = 1;
    for( ; i &amp;lt; m; ++i )
        dp[i][0] = 0;
    // 起点位置, 横线Path为1, 遇到障碍之后的为0
    int j = 0;
    for( ; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j]==0; ++j )
        dp[0][j] = 1;
    for( ; j &amp;lt; n; ++j )
        dp[0][j] = 0;

    for( i = 1; i &amp;lt; m; ++i )
        for( j = 1; j &amp;lt; n; ++j )
            if( obstacleGrid[i][j] == 0 )
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            else
                dp[i][j] = 0;

    return dp[m-1][n-1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 同UniquePaths相同, 在此基础上多了障碍的设置, 那么我们只需要考虑障碍带来的影响就可以了:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化横线和竖线的时候, 如果遇到障碍, 之后都是不可达的&lt;/li&gt;
  &lt;li&gt;在递推过程中, 如果遇到障碍, 那么该格子是不可达的, 值为0&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;时空复杂度: 时间复杂度是(mn), 空间复杂度是(mn)&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/02/leetcode-UniquePaths(II)/</link>
        <guid isPermaLink="true">/2016/04/02/leetcode-UniquePaths(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>JUnit</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#junit&quot; id=&quot;markdown-toc-junit&quot;&gt;JUnit简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit-1&quot; id=&quot;markdown-toc-junit-1&quot;&gt;JUnit的原理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-2&quot; id=&quot;markdown-toc-junit-2&quot;&gt;JUnit结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-3&quot; id=&quot;markdown-toc-junit-3&quot;&gt;JUnit核心类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-4&quot; id=&quot;markdown-toc-junit-4&quot;&gt;JUnit生命周期&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-5&quot; id=&quot;markdown-toc-junit-5&quot;&gt;JUnit中的设计模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;junit&quot;&gt;JUnit简介&lt;/h3&gt;

&lt;p&gt;JUnit就是为Java程序开发者实现单元测试提供一种框架，使得Java单元测试更规范有效，并且更有利于测试的集成&lt;/p&gt;

&lt;h3 id=&quot;junit-1&quot;&gt;JUnit的原理&lt;/h3&gt;

&lt;h4 id=&quot;junit-2&quot;&gt;JUnit结构&lt;/h4&gt;

&lt;p&gt;JUnit中有7个包, 每个包的简要说明如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;包名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.awtui&lt;/td&gt;
      &lt;td&gt;以awt界面组件来显示junit测试过程结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.swingui&lt;/td&gt;
      &lt;td&gt;以swing界面组件来显示junit测试过程结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.textui&lt;/td&gt;
      &lt;td&gt;以控制台输出来显示junit测试过程结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.framework&lt;/td&gt;
      &lt;td&gt;junit的核心功能包, 包括Test/TestCase/TestSuite/TestResult/TestListener等类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.runner&lt;/td&gt;
      &lt;td&gt;junit核心功能包, 主要运行Test类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.extensions&lt;/td&gt;
      &lt;td&gt;junit扩展功能包&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;junit-3&quot;&gt;JUnit核心类&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/software-testing/junit-main-class.jpg&quot; alt=&quot;junit-main-class&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Test&lt;/td&gt;
      &lt;td&gt;用于运行测试和收集测试结果, 还可以获取测试用例个数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestCase&lt;/td&gt;
      &lt;td&gt;Test接口的一个实现类, 给出了测试的基本实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestSuite&lt;/td&gt;
      &lt;td&gt;Test接口的另一个实现类, 可以包含多个TestCase&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestResult&lt;/td&gt;
      &lt;td&gt;包含收集到的测试结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestListener&lt;/td&gt;
      &lt;td&gt;测试流程的监听接口, 可以开始/结束测试, 可以添加failures/errors&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;junit-4&quot;&gt;JUnit生命周期&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/software-testing/junit-life.png&quot; alt=&quot;junit-life&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;junit-5&quot;&gt;JUnit中的设计模式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Template Method&lt;/p&gt;

    &lt;p&gt;实质就是首先建立方法的骨架，而尽可能地将方法的具体实现向后推移.&lt;/p&gt;

    &lt;p&gt;TestCase.runBare()就采用了这种模式，客户类均可以重载它的三个方法，这样使得测试的可伸缩性得到提高.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public void runBare() throws Throwable{ 
      setUp(); 
      try {
          runTest();
      } finally {
          tearDown();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Command&lt;/p&gt;

    &lt;p&gt;实质就是将动作封装为一个对象，而不关心动作的接收者。这样动作的接收者可以一直到动作具体执行时才需确定.&lt;/p&gt;

    &lt;p&gt;接口Test就是一个Command集，使得不同类的不同测试方法可以通过同一种接口Test构造其框架结构。这样对测试的集成带来了很多方便.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/01/software-testing-junit/</link>
        <guid isPermaLink="true">/2016/04/01/software-testing-junit/</guid>
        
        
        <category>软件测试</category>
        
      </item>
    
      <item>
        <title>BestTimeToBuyAndSellStock(II)(III)(IV)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock&quot; id=&quot;markdown-toc-besttimetobuyandsellstock&quot;&gt;BestTimeToBuyAndSellStock&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock-ii&quot; id=&quot;markdown-toc-besttimetobuyandsellstock-ii&quot;&gt;BestTimeToBuyAndSellStock II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock-iv&quot; id=&quot;markdown-toc-besttimetobuyandsellstock-iv&quot;&gt;BestTimeToBuyAndSellStock IV&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock-iii&quot; id=&quot;markdown-toc-besttimetobuyandsellstock-iii&quot;&gt;BestTimeToBuyAndSellStock III&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock&quot;&gt;BestTimeToBuyAndSellStock&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;暴力法&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxProfitBruteForce( int[] prices ) {
      int maxProfit = 0;
      for( int i = 0; i &amp;lt; prices.length-1; ++i ) {
          for( int j = i+1; j &amp;lt; prices.length; ++j ) {
              if( prices[j] - prices[i] &amp;gt; maxProfit )
                  maxProfit = prices[j] - prices[i];
          }
      }
      return maxProfit;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 对于每一天, 我们都计算出这一天卖出可以获得的maxProfit&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(n^2), 空间复杂度是O(1)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分治法&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxProfitDivideAndConquer( 
          int[] prices, int left, int right ) {
      if( left &amp;gt;= right ) return 0;
      int mid = left + (right-left)/2;
      int leftMaxProfit = maxProfitDivideAndConquer( prices, left, mid );
      int rightMaxProfit = maxProfitDivideAndConquer( prices, mid+1, right );
      // 求出左半部分最低价
      int leftMin = mid;
      for( int i = mid; i &amp;gt;= left; --i )
          if( prices[i] &amp;lt; prices[leftMin] )
              leftMin = i;

      // 求出右半部分最高价
      int rightMax = mid;
      for( int i = mid; i &amp;lt;= right; ++i )
          if( prices[i] &amp;gt; prices[rightMax] )
              rightMax = i;

      return Math.max( 
              Math.max( leftMaxProfit, rightMaxProfit ), 
              prices[rightMax]-prices[leftMin] );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 对于给定的一段时间&lt;code class=&quot;highlighter-rouge&quot;&gt;[left...right]&lt;/code&gt;, 我们从中间mid把时间段切割为&lt;code class=&quot;highlighter-rouge&quot;&gt;[left...mid]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;[mid+1...right]&lt;/code&gt;, 那么在&lt;code class=&quot;highlighter-rouge&quot;&gt;[left...right]&lt;/code&gt;这段时间的解为以下的情况之一:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;[left…mid] 的maxProfit&lt;/li&gt;
      &lt;li&gt;[mid+1…right] 的maxProfit&lt;/li&gt;
      &lt;li&gt;右半部分最高价 - 左半部分最低价&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(nlogn), 空间复杂度是O(logn)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxProfitDP( int[] prices ) {
      int leftMin = 0, maxProfit = 0;
      for( int i = 1; i &amp;lt; prices.length; ++i ) {
          if( prices[i] - prices[leftMin] &amp;gt; maxProfit )
              maxProfit = prices[i] - prices[leftMin];
          if( prices[i] &amp;lt; prices[leftMin] )
              leftMin = i;
      }
      return maxProfit;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 由前面的暴力法可知, 我们对每一天都求出这一天卖出的maxProfit, 而这个maxProfit实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;当天价格-历史价格最低价&lt;/code&gt;. 暴力法中我们遍历查询历史价格, 其实我们可以用一个变量来记录历史价格最低价, 也就是代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;leftMin&lt;/code&gt;. 这样可以把查询时间从O(n)降到O(1).&lt;/p&gt;

    &lt;p&gt;这种解法看似与DP没什么关系, 只是在原来的基础上做出了优化而已, 其实这个优化就是动态规划的思想了. 其体现如下:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;最优子结构: maxProfit[i] = max( maxProrit[i-1], prices[i]-prices[leftMin] )&lt;/li&gt;
      &lt;li&gt;重叠子问题: leftMin的查找&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock-ii&quot;&gt;BestTimeToBuyAndSellStock II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProfit( int[] prices ) {
    // S表示前一次卖的日期, B表示前一次买的日期
    int S = 0, B = 0, maxProfit = 0;
    for( int i = 1; i &amp;lt; prices.length; ++i ) {
        if( B &amp;gt;= S ) {        // 最近一次交易是买
            if( prices[i] &amp;lt; prices[B] ) {
                B = i;
            } else if( prices[i] &amp;gt; prices[B] ) {
                maxProfit += prices[i] - prices[B];
                S = i;
            } 
        } else {            // 最近一次交易是卖
            if( prices[i] &amp;gt; prices[S] ) {
                maxProfit += prices[i] - prices[S];
                S = i;
            } else if( prices[i] &amp;lt; prices[S] ) {
                B = i;
            }
        }
    }
    return maxProfit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 因为交易次数无限, 所以只要赚钱就卖出去, 低价就买回来 – &lt;code class=&quot;highlighter-rouge&quot;&gt;贪心算法&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们使用两个变量: &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;表示前一次卖出的日期, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;表示前一次买进的日期. 对于每一天, 先判断最近一次交易是买还是卖.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最近一次交易是买, 如果今天价格更低就当作今天才买进, 如果今天价格更高就卖出去.&lt;/li&gt;
  &lt;li&gt;最近一次交易是卖, 如果今天价格更高就当作今天才卖出, 如果今天价格更低就买进来.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock-iv&quot;&gt;BestTimeToBuyAndSellStock IV&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most k transactions.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProfitDP( int k, int[] prices ) {
    int len = prices.length;

    // 如果交易次数超过最大交易次数, 获取最大利润
    if( k &amp;gt; len/2 ) return quickSolve( prices );

    // dp[i][j]: 在第j天之前交易i次可以获得的最大利润
    int[][] dp = new int[k+1][len];
    for( int i = 1; i &amp;lt;= k; ++i ) {
        // holds: 买进状态下, 目前持有的最大利润
        int holds = -prices[0];
        for( int j = 1; j &amp;lt; len; ++j ) {
            dp[i][j] = Math.max( dp[i][j-1], holds+prices[j] );
            holds = Math.max( holds, dp[i-1][j-1]-prices[j] );
        }
    }
    return dp[k][len-1];
}

private static int quickSolve( int[] prices ) {
    int profit = 0;
    for( int i = 1; i &amp;lt; prices.length; ++i )
        if( prices[i] &amp;gt; prices[i-1] )
            profit += prices[i] - prices[i-1];
    return profit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 我们的目的是找到n天之内进行最多k次交易的最大利润, 那么我们给出以下定义:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;: j天之内进行最多i次交易的最大利润&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们发现dp[i][j]可能与价格prices[j]有关, 也可能无关.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果无关, 容易知道&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;等于&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j-1]&lt;/code&gt; (最优子结构性质)&lt;/li&gt;
  &lt;li&gt;如果有关, &lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;是如何影响&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;的取值的呢? 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;能够影响&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;, 那么就只能是&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;这个价格卖出获得更大的利润. 所以就需要记录一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;holds: 买进状态下, 持有的最大利润&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分析到这里就会发现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dp[i][j] = max( dp[i][j-1], holds+prices[j] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么&lt;code class=&quot;highlighter-rouge&quot;&gt;holds&lt;/code&gt;是如何受&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;的影响的呢? 因为holds表示买进状态, 所以如果&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;能够影响&lt;code class=&quot;highlighter-rouge&quot;&gt;holds&lt;/code&gt;, 那么就只能是买进&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;, 而且买进之前的最大利润是&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j-1]&lt;/code&gt;, 所以&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;holds = max( holds, dp[i-1][j-1]-prices[j] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(kn), 空间复杂度是O(kn)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock-iii&quot;&gt;BestTimeToBuyAndSellStock III&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most two transactions.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProfitDP( int[] prices ) {
    int len = prices.length;
    int k = 2;
    // 如果交易次数超过最大交易次数, 获取最大利润
    if( k &amp;gt; len/2 ) return quickSolve( prices );

    // dp[i][j]: 在第j天之前交易i次可以获得的最大利润
    int[][] dp = new int[k+1][len];
    for( int i = 1; i &amp;lt;= k; ++i ) {
        // holds: 买进状态下, 目前持有的最大利润
        int holds = -prices[0];
        for( int j = 1; j &amp;lt; len; ++j ) {
            dp[i][j] = Math.max( dp[i][j-1], holds+prices[j] );
            holds = Math.max( holds, dp[i-1][j-1]-prices[j] );
        }
    }
    return dp[k][len-1];
}

private static int quickSolve( int[] prices ) {
    int profit = 0;
    for( int i = 1; i &amp;lt; prices.length; ++i )
        if( prices[i] &amp;gt; prices[i-1] )
            profit += prices[i] - prices[i-1];
    return profit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 这是上一题中k=2的特殊情况&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(n)&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/01/leetcode-BestTimeToBuyAndSellStock(II)(III)(IV)/</link>
        <guid isPermaLink="true">/2016/04/01/leetcode-BestTimeToBuyAndSellStock(II)(III)(IV)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>动态规划原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;动态规划定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;动态规划原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;动态规划的基本要素&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;最优子结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;重叠子问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;动态规划的变形&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;备忘录方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;动态规划定义&lt;/h3&gt;

&lt;p&gt;动态规划算法是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;计算算法&lt;/code&gt;, 可以在多项式时间计算出问题的解&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;动态规划原理&lt;/h3&gt;

&lt;p&gt;动态规划的计算原理是&lt;code class=&quot;highlighter-rouge&quot;&gt;问题分解&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原理: 动态规划算法与分治法类似, 基本思想是&lt;code class=&quot;highlighter-rouge&quot;&gt;将待求解问题分解为若干个子问题, 先求解子问题, 然后从子问题的解得到原始问题的解&lt;/code&gt;. 与分治法不同的是, 动态规划划分出来的&lt;code class=&quot;highlighter-rouge&quot;&gt;子问题往往不是相互独立的&lt;/code&gt;. 若用分治法来解这类问题, 则分解得到的子问题数目太多, 以至于需要耗费指数时间解决问题, 而子问题的数目常常只有多项式量级. 在用分治法求解时, 有些子问题被重复计算了很多次. 如果我们能够保存已解决的子问题答案, 在需要的时候查一下, 这样就可以避免大量的重复计算, 从而得到多项式时间算法. 为了达到此目的, 可以用一个表来记录已解决的子问题答案. 不管该子问题以后是否被用到, 只要它被计算过, 就将其结果填入表中. 这就是动态规划的基本思想.&lt;/p&gt;

&lt;p&gt;动态规划算法适用于解&lt;code class=&quot;highlighter-rouge&quot;&gt;最优化问题&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法的步骤如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;找出最优解的性质, 并刻画其结构特征&lt;/li&gt;
    &lt;li&gt;递归定义最优值&lt;/li&gt;
    &lt;li&gt;以自底向顶的方式计算出最优值&lt;/li&gt;
    &lt;li&gt;根据计算最优值时得到的信息, 构造最优解&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;动态规划的基本要素&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;最优子结构&lt;/h4&gt;

&lt;p&gt;设计动态规划算法的第一步通常是刻画最优解的结构. &lt;code class=&quot;highlighter-rouge&quot;&gt;当问题的最优解包含了其子问题的最优解是, 称该问题具有最优子结构性质&lt;/code&gt;. 问题具有最优子结构性质提供了可用动态规划算法求解的重要线索.&lt;/p&gt;

&lt;p&gt;分析问题的最优子结构性质时, 所用的方法具有普遍性, 就是&lt;code class=&quot;highlighter-rouge&quot;&gt;反证法&lt;/code&gt;. 首先假设问题的最优解导出的子问题的解不是最优的, 然后再分析说明在这个假设下, 可以构造出比原有问题最优解更好的解, 从而导致矛盾.&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;重叠子问题&lt;/h4&gt;

&lt;p&gt;在用递归算法自顶向底解问题时, 每次产生的子问题并不总是新问题, 有些子问题被反复计算多次. 动态规划算法正是利用了这种子问题的重叠性质, 对每一个子问题只解一次, 而后将其解保存在一个表格中, 当需要再次解此子问题时, 只是以简单地查询一下. 通常, 不同的子问题个数随问题的大小呈多项式增长. 因此, 用动态规划算法通常只需要多项式时间, 从而获得较高的解题效率.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;动态规划的变形&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;备忘录方法&lt;/h4&gt;

&lt;p&gt;备忘录方法用表格保存已解决子问题的答案, 在下次需要解此子问题时, 只要简单查看该子问题的答案, 而不必重新计算. 与动态规划算法不同的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;备忘录方法的递归方式是自顶向底的, 而动态规划算法则是自底向顶的&lt;/code&gt;. 因此, 备忘录方法的控制结构与动态规划的控制结构相同, 区别在于备忘录方法为每个解过的子问题建立备忘录以备查询.&lt;/p&gt;

&lt;p&gt;备忘录方法为每个子问题建立一个记录项, 初始化时, 该记录项存入一个特殊值, 表示该子问题尚未求解. 在求解过程中, 对每个待求的子问题, 首先查看相应的记录项. 如果存储的是特殊值, 则表示该子问题是第一次遇到, 此时计算该子问题的解并保存进记录项. 如果存储的不是特殊值, 则表示该子问题已经被计算过, 此时直接查询返回即可.&lt;/p&gt;

&lt;p&gt;一般来讲, 当一个问题的所有子问题都至少需要解一次时, 用动态规划算法比备忘录方法好. 此时动态规划算法没有任何多余的计算. 同时, 对于许多问题, 常可利用其规则的表格存取方式, 减少动态规划算法的计算时间和空间需求. 当子问题空间中的部分字问题可不必求解时, 用备忘录方法则较有利, 因为从其控制结构可以看出, 该方法只解那些确实需要求解的子问题.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/01/algorithm-dynamic-programming/</link>
        <guid isPermaLink="true">/2016/04/01/algorithm-dynamic-programming/</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>Combinations</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinations&quot; id=&quot;markdown-toc-combinations&quot;&gt;Combinations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinations&quot;&gt;Combinations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombine( n, 1, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}
public static void helperCombine( 
        int n, int t, int k, List&amp;lt;Integer&amp;gt; tmpRes, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res ) {
    // 约束条件
    if( t &amp;gt; n ) {
        return;
    }
    // 不选取当前值
    helperCombine( n, t+1, k, tmpRes, res );
    
    // 选取当前值
    tmpRes.add( t );
    if( k-1 == 0 ) {    // 获得一个结果
        res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
    } else {            // 进入下一层
        helperCombine( n, t+1, k-1, tmpRes, res );
    }
    tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于[1…n]中的每一个元素, 可取可不取&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;放在方法头部更容易理解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-Combinations/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-Combinations/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>CombinationSum(II)(III)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum&quot; id=&quot;markdown-toc-combinationsum&quot;&gt;CombinationSum&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum-ii&quot; id=&quot;markdown-toc-combinationsum-ii&quot;&gt;CombinationSum II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum-iii&quot; id=&quot;markdown-toc-combinationsum-iii&quot;&gt;CombinationSum III&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinationsum&quot;&gt;CombinationSum&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;

  &lt;p&gt;The same repeated number may be chosen from C unlimited number of times.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
    &lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, &amp;gt; a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example, given candidate set 2,3,6,7 and target 7,
A solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[7]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 2, 3]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum( 
        int[] candidates, int target ) {
    // 排序, 后面才可以进行剪枝
    Arrays.sort( candidates );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombinationSum2( 
            candidates, target, 0, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperCombinationSum2(
        int[] candidates, int target, int t, List&amp;lt;Integer&amp;gt; tmpRes, 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
    // 约束条件
    if( t == candidates.length ) {
        return;
    }
    // 剪枝
    if( candidates[t] &amp;gt; target ) {
        return;
    }
    
    // 遍历解空间
    int i = 0;
    for( ; i*candidates[t] &amp;lt;= target; ++i ) {
        if( i != 0 ) tmpRes.add( candidates[t] );
        if( i*candidates[t] == target ) {
            res.add( new ArrayList&amp;lt;Integer&amp;gt;( tmpRes) );
        } else {
            helperCombinationSum2( candidates, 
            	target-i*candidates[t], t+1, tmpRes, res );
        }
    }
    while( i-- &amp;gt; 1 )
        tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于candidates数组中的每一个值, 可以无限重复取, 但是实际上只要取到一定程度就就可以结束了, 结束条件: i*candidates[t] &amp;gt; target, 也就是取[0…i]的情况, [i+1…∞]不取.&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;combinationsum-ii&quot;&gt;CombinationSum II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;

  &lt;p&gt;Each number in C may only be used once in the combination.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
    &lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example, given candidate set 10,1,2,7,6,1,5 and target 8,&lt;/p&gt;

  &lt;p&gt;A solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 7]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 5]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 6]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 1, 6]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2( 
		int[] candidates, int target ) {
	// 排序, 后面才可以进行剪枝
	Arrays.sort( candidates );
	List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
	helperCombinationSum( 
			candidates, target, 0, new ArrayList&amp;lt;Integer&amp;gt;(), res );
	return res;
}

private static void helperCombinationSum(
		int[] candidates, int target, int t, List&amp;lt;Integer&amp;gt; tmpRes, 
		List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
	if( t == candidates.length ) {
		return;
	}
	// 剪枝
	if( candidates[t] &amp;gt; target ) {
		return;
	}
	
	// 统计重复元素个数
	int repeatCount = 0;
	while( repeatCount+t &amp;lt; candidates.length &amp;amp;&amp;amp; 
			candidates[t] == candidates[t+repeatCount])
		++repeatCount;
	
	// 遍历解空间
	int i = 0;
	for( ; i &amp;lt;= repeatCount &amp;amp;&amp;amp; i*candidates[t] &amp;lt;= target; ++i ) {
		if( i != 0 ) tmpRes.add( candidates[t] );
		if( i*candidates[t] == target ) {
			res.add( new ArrayList&amp;lt;Integer&amp;gt;( tmpRes) );
		} else {
			helperCombinationSum( candidates, 
			    target-i*candidates[t], t+repeatCount, tmpRes, res );
		}
	}
	while( i-- &amp;gt; 1 )
		tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 同CombinationSum一样. 不一样的地方: CombinationSum中的每个元素取[0,∞]个, 这里每个元素取[0…R]个, R表示元素的重复个数, 所以代码里面就多了限制条件: &lt;code class=&quot;highlighter-rouge&quot;&gt;i &amp;lt;= repeatCount&lt;/code&gt; 而且进入下一层要跨越重复元素: &lt;code class=&quot;highlighter-rouge&quot;&gt;t+repeatCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型, 思考新问题中&lt;code class=&quot;highlighter-rouge&quot;&gt;影响因素&lt;/code&gt;对结果产生的影响, 并且从原有模型中调整得到解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;combinationsum-iii&quot;&gt;CombinationSum III&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;

  &lt;p&gt;Ensure that numbers within the set are sorted in ascending order.&lt;/p&gt;

  &lt;p&gt;Example 1:&lt;/p&gt;

  &lt;p&gt;Input: k = 3, n = 7&lt;/p&gt;

  &lt;p&gt;Output:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,2,4]]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;Example 2:&lt;/p&gt;

  &lt;p&gt;Input: k = 3, n = 9&lt;/p&gt;

  &lt;p&gt;Output:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,2,6], [1,3,5], [2,3,4]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-6&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombinationSum3( n, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperCombinationSum3( int n, int k, List&amp;lt;Integer&amp;gt; tmpRes, 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
    // 约束条件
    if( k &amp;lt;= 0 || n &amp;lt;= 0 ) {
        return;
    }
    
    // 保证结果子集中不可能出现重复元素
    int i = tmpRes.size()==0 ? 1 : tmpRes.get(tmpRes.size()-1)+1;
    for( ; i &amp;lt;= 9; ++i ) {
        tmpRes.add( i );
        if( n-i == 0 &amp;amp;&amp;amp; k-1 == 0 ) {
            res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
        } else {
            helperCombinationSum3( n-i, k-1, tmpRes, res );
        }
        tmpRes.remove( tmpRes.size()-1 );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 本质上跟上面两题都是一样的. 不同的地方就是: &lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;解空间的遍历方式&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-CombinationSum(II)(III)/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-CombinationSum(II)(III)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>进程的查看</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ps&quot; id=&quot;markdown-toc-ps&quot;&gt;ps指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-1&quot; id=&quot;markdown-toc-ps-1&quot;&gt;ps参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-2&quot; id=&quot;markdown-toc-ps-2&quot;&gt;ps使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#t-o-p&quot; id=&quot;markdown-toc-t-o-p&quot;&gt;t-o-p指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-1&quot; id=&quot;markdown-toc-t-o-p-1&quot;&gt;t-o-p参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-2&quot; id=&quot;markdown-toc-t-o-p-2&quot;&gt;t-o-p程序指令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-3&quot; id=&quot;markdown-toc-t-o-p-3&quot;&gt;t-o-p使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pstree&quot; id=&quot;markdown-toc-pstree&quot;&gt;pstree指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-1&quot; id=&quot;markdown-toc-pstree-1&quot;&gt;pstree参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-2&quot; id=&quot;markdown-toc-pstree-2&quot;&gt;pstree使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps&quot;&gt;ps指令&lt;/h3&gt;

&lt;h4 id=&quot;ps-1&quot;&gt;ps参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;显示所有的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;排除与终端有关的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;指定特定用户的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;显示更完整的信息, 与a参数一起使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;长格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;工作格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;完整格式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;ps-2&quot;&gt;ps使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看与bash相关的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps -l
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-l.png&quot; alt=&quot;ps-l&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;F&lt;/td&gt;
          &lt;td&gt;4表示进程权限为root, 1表示进程只能fork, 不能执行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;S&lt;/td&gt;
          &lt;td&gt;进程的STATE, R-&amp;gt;运行, S-&amp;gt;睡眠, D-&amp;gt;阻塞, T-&amp;gt;停止, Z-&amp;gt;僵尸&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;UID&lt;/td&gt;
          &lt;td&gt;用户ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PPID&lt;/td&gt;
          &lt;td&gt;父进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;C&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PRI/NI&lt;/td&gt;
          &lt;td&gt;进程优先级相关, 越小优先级越高&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ADDR&lt;/td&gt;
          &lt;td&gt;进程内存地址&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SZ&lt;/td&gt;
          &lt;td&gt;消耗的内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;WCHAN&lt;/td&gt;
          &lt;td&gt;运行状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;CMD&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统所有的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-aux.png&quot; alt=&quot;ps-aux&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VSZ&lt;/td&gt;
          &lt;td&gt;虚拟内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RSS&lt;/td&gt;
          &lt;td&gt;内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;STAT&lt;/td&gt;
          &lt;td&gt;进程状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;START&lt;/td&gt;
          &lt;td&gt;进程启动时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统某进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux | egrep &#39;xrgsu&#39;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-egrep.png&quot; alt=&quot;ps-egrep&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;t-o-p&quot;&gt;t-o-p指令&lt;/h3&gt;

&lt;h4 id=&quot;t-o-p-1&quot;&gt;t-o-p参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;更新频率, 以秒为单位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b&lt;/td&gt;
      &lt;td&gt;批处理, 通常配合数据流重定向&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;与-b配合, 指定批处理总次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;检测指定进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-2&quot;&gt;t-o-p程序指令&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;查看top程序指令帮助&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;按照CPU使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;按照内存使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;按照PID排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;按照CPU运行总时长排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;kill进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;重新给进程nice值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;q&lt;/td&gt;
      &lt;td&gt;退出top&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-3&quot;&gt;t-o-p使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每隔2秒更新一次资源状态&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -d 2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-top-d2.png&quot; alt=&quot;top-d2&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PR/NI&lt;/td&gt;
          &lt;td&gt;优先级&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VIRT&lt;/td&gt;
          &lt;td&gt;虚拟内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RES&lt;/td&gt;
          &lt;td&gt;内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SHR&lt;/td&gt;
          &lt;td&gt;共享内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME+&lt;/td&gt;
          &lt;td&gt;CPU使用累积时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把资源状态结果输出到文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -b -n 2 &amp;gt; /tmp/top.txt
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pstree&quot;&gt;pstree指令&lt;/h3&gt;

&lt;h4 id=&quot;pstree-1&quot;&gt;pstree参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;以ASCII字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-U&lt;/td&gt;
      &lt;td&gt;以UTF8字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;显示进程所属用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;显示进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;pstree-2&quot;&gt;pstree使用实例&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pstree -Uup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/linux/linux-pstree-Uup.png&quot; alt=&quot;pstree-Uup&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/linux-process-check/</link>
        <guid isPermaLink="true">/2016/03/30/linux-process-check/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Permutations(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations&quot; id=&quot;markdown-toc-permutations&quot;&gt;Permutations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations-ii&quot; id=&quot;markdown-toc-permutations-ii&quot;&gt;Permutations II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;permutations&quot;&gt;Permutations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,2,3] have the following permutations:&lt;/p&gt;

  &lt;p&gt;[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute( int[] nums ) {
    helperPermute( nums, 0 );
    return res;
}
private static void helperPermute( int[] nums, int t ) {
    if( t == nums.length ) {
        // 构造一个结果
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        
        // 加入结果集
        res.add( tmpRes );
    } else {
        for( int i = t; i &amp;lt; nums.length; ++i ) {
            swap( nums, t, i);
            helperPermute( nums, t+1 );
            swap( nums, t, i);
        }
    }
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个集合的全排列, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;排列树&lt;/code&gt;问题.&lt;/p&gt;

&lt;p&gt;代码可以这样理解, 集合S的全排列由以下的结果组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S[1]+全排列( S[2…n] )&lt;/li&gt;
  &lt;li&gt;S[2]+全排列( S[1, 3…n] )&lt;/li&gt;
  &lt;li&gt;S[3]+全排列( S[2, 1, 4…n] )&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;S[n]+全排列( S[1…n-1] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是把S的中每一个元素都提取到第一位, 剩下的元素做全排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 为什么要swap2次? 因为我们要保证在处理完一次结果之后, 要恢复数组的原始状态, 这样下一次处理的时候才能正确把下一个元素交换到第一个位置来.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的全排列&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个处理过程是迭代形式的, 而且迭代过程有严格的状态要求, 那么就十分需要注意子处理过程所带来的影响.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;permutations-ii&quot;&gt;Permutations II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

  &lt;p&gt;[1,1,2], [1,2,1], and [2,1,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique( int[] nums ) {
    Arrays.sort( nums );
    helperPermuteUnique( nums, 0, nums.length-1 );
    return res;
}
private static void helperPermuteUnique( int[] nums, int i, int j ) {
    if( i == j ) {
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        res.add( tmpRes );
    } 
    for( int k = i; k &amp;lt;= j; ++k ) {
        if( findSame(nums, i, k) ) continue;
        swap( nums, i, k );
        helperPermuteUnique( nums, i+1, j );
        swap( nums, i, k );
    }
}

private static boolean findSame( int[] nums, int i, int j ) {
    for( int k = i; k &amp;lt; j; ++k )
        if( nums[j] == nums[k] ) return true;
    return false;
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 对于有重复元素集合的全排列, 可以用上面无重复元素的全排列来解决, 区别就是我们在这个基础上还要排除一些重复的全排列, 那么我们需要思考的问题是: 按照无重复元素的全排列处理过程, 如何消除重复元素带来的影响? 我们知道全排列的一次处理过程就是把每一个元素都搬到第一个位置, 然后做剩余元素的全排列, 所以我们只需要判断当前元素跟前面的元素有没有重复, 有重复的话就是已经处理过的, 直接跳过.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型去思考问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-permutations(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-permutations(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Next Permutation</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically &amp;gt; next greater permutation of numbers.&lt;/p&gt;

  &lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible &amp;gt; order (ie, sorted in ascending order).&lt;/p&gt;

  &lt;p&gt;The replacement must be in-place, do not allocate extra memory.&lt;/p&gt;

  &lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding &amp;gt; outputs are in the right-hand column.&lt;/p&gt;

  &lt;p&gt;1,2,3 → 1,3,2&lt;/p&gt;

  &lt;p&gt;3,2,1 → 1,2,3&lt;/p&gt;

  &lt;p&gt;1,1,5 → 1,5,1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void nextPermutation( int[] nums ) {

    // 从后往前找到第一个递增对 [i, i+1]
    int i = nums.length-2;
    for( ; i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i+1]; --i );

    // 已经不存在递增对, 所有排列已经列举完了, 这里重新开始
    if( i &amp;lt; 0 ) {
        reverse( nums, 0, nums.length-1 );
        return;
    }

    // 从后往前找到第一个 [j] &amp;gt; [i]
    int j = nums.length-1;
    for( ; j &amp;gt; i &amp;amp;&amp;amp; nums[j] &amp;lt;= nums[i]; --j );

    // 构造下一个全排列
    swap( nums, i, j );
    i = i + 1;
    j = nums.length-1;
    reverse( nums, i, j );
}
private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
private static void reverse( int[] nums, int i, int j ) {
    while( i &amp;lt; j ) {
        swap( nums, i++, j-- );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个排列的下一个排列, 从数值上看, 就是找到下一个值, 使得下一个值&lt;code class=&quot;highlighter-rouge&quot;&gt;比当前值大&lt;/code&gt;并且要&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;. 所以我们可以从数值的低位部分入手, 因为改变低位对数值大小的影响最小, 也就满足了&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;这个条件. 现在考虑一个例子:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, … , A&lt;sub&gt;K&lt;/sub&gt;, A&lt;sub&gt;K+1&lt;/sub&gt;, …, A&lt;sub&gt;N&lt;/sub&gt;]&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;K+1&lt;/sub&gt; &amp;gt; … &amp;gt; A&lt;sub&gt;N&lt;/sub&gt; ( 1 &amp;lt; K &amp;lt; N, 也就是[K+1…N]递减 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于[K+1…N]这部分是递减的, 那么在这部分做修改是不可能构造出一个比当前值还大的值, 所以就要第[K]位加进来, 也就是对[K…N]这部分做修改, 那么该如何改呢?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在[K+1…N]中找一个刚好比[K]大的值, 与[K]交换, 才能构造出一个比当前值大的值, 所以就可以在[K+1…N]中由后往前找合适的值([K+1…N]是递减的, 所以由后往前找)&lt;/li&gt;
  &lt;li&gt;找到合适的值之后与[K]交换, 交换之后[K+1…N]还是递减的&lt;/li&gt;
  &lt;li&gt;修改[K+1…N]这部分变为最小值, 因为[K+1…N]是递减的, 翻转以下就可以了&lt;/li&gt;
  &lt;li&gt;得到下一个全排列的值&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 求下一个排列的问题可以转化为数值的问题, 然后又要想到数值的变化影响因素中, 低位的影响是最小的, 所以思考点要转移到如何修改低位部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;专注问题的思考点, 并且不断转换思考点, 直到问题清晰可解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-next-permutation/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-next-permutation/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
  </channel>
</rss>
