<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SCH</title>
    <description>苏灿灏的博客 大数据爱好者</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 31 Mar 2016 12:57:59 +0800</pubDate>
    <lastBuildDate>Thu, 31 Mar 2016 12:57:59 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Combinations</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinations&quot; id=&quot;markdown-toc-combinations&quot;&gt;Combinations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinations&quot;&gt;Combinations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombine( n, 1, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}
public static void helperCombine( 
        int n, int t, int k, List&amp;lt;Integer&amp;gt; tmpRes, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res ) {
    // 约束条件
    if( t &amp;gt; n ) {
        return;
    }
    // 不选取当前值
    helperCombine( n, t+1, k, tmpRes, res );
    
    // 选取当前值
    tmpRes.add( t );
    if( k-1 == 0 ) {    // 获得一个结果
        res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
    } else {            // 进入下一层
        helperCombine( n, t+1, k-1, tmpRes, res );
    }
    tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于[1…n]中的每一个元素, 可取可不取&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;放在方法头部更容易理解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-Combinations/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-Combinations/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>进程的查看</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ps&quot; id=&quot;markdown-toc-ps&quot;&gt;ps指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-1&quot; id=&quot;markdown-toc-ps-1&quot;&gt;ps参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-2&quot; id=&quot;markdown-toc-ps-2&quot;&gt;ps使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#t-o-p&quot; id=&quot;markdown-toc-t-o-p&quot;&gt;t-o-p指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-1&quot; id=&quot;markdown-toc-t-o-p-1&quot;&gt;t-o-p参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-2&quot; id=&quot;markdown-toc-t-o-p-2&quot;&gt;t-o-p程序指令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-3&quot; id=&quot;markdown-toc-t-o-p-3&quot;&gt;t-o-p使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pstree&quot; id=&quot;markdown-toc-pstree&quot;&gt;pstree指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-1&quot; id=&quot;markdown-toc-pstree-1&quot;&gt;pstree参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-2&quot; id=&quot;markdown-toc-pstree-2&quot;&gt;pstree使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps&quot;&gt;ps指令&lt;/h3&gt;

&lt;h4 id=&quot;ps-1&quot;&gt;ps参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;显示所有的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;排除与终端有关的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;指定特定用户的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;显示更完整的信息, 与a参数一起使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;长格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;工作格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;完整格式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;ps-2&quot;&gt;ps使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看与bash相关的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps -l
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-l.png&quot; alt=&quot;ps-l&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;F&lt;/td&gt;
          &lt;td&gt;4表示进程权限为root, 1表示进程只能fork, 不能执行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;S&lt;/td&gt;
          &lt;td&gt;进程的STATE, R-&amp;gt;运行, S-&amp;gt;睡眠, D-&amp;gt;阻塞, T-&amp;gt;停止, Z-&amp;gt;僵尸&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;UID&lt;/td&gt;
          &lt;td&gt;用户ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PPID&lt;/td&gt;
          &lt;td&gt;父进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;C&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PRI/NI&lt;/td&gt;
          &lt;td&gt;进程优先级相关, 越小优先级越高&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ADDR&lt;/td&gt;
          &lt;td&gt;进程内存地址&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SZ&lt;/td&gt;
          &lt;td&gt;消耗的内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;WCHAN&lt;/td&gt;
          &lt;td&gt;运行状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;CMD&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统所有的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-aux.png&quot; alt=&quot;ps-aux&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VSZ&lt;/td&gt;
          &lt;td&gt;虚拟内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RSS&lt;/td&gt;
          &lt;td&gt;内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;STAT&lt;/td&gt;
          &lt;td&gt;进程状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;START&lt;/td&gt;
          &lt;td&gt;进程启动时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统某进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux | egrep &#39;xrgsu&#39;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-egrep.png&quot; alt=&quot;ps-egrep&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;t-o-p&quot;&gt;t-o-p指令&lt;/h3&gt;

&lt;h4 id=&quot;t-o-p-1&quot;&gt;t-o-p参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;更新频率, 以秒为单位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b&lt;/td&gt;
      &lt;td&gt;批处理, 通常配合数据流重定向&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;与-b配合, 指定批处理总次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;检测指定进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-2&quot;&gt;t-o-p程序指令&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;查看top程序指令帮助&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;按照CPU使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;按照内存使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;按照PID排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;按照CPU运行总时长排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;kill进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;重新给进程nice值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;q&lt;/td&gt;
      &lt;td&gt;退出top&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-3&quot;&gt;t-o-p使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每隔2秒更新一次资源状态&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -d 2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-top-d2.png&quot; alt=&quot;top-d2&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PR/NI&lt;/td&gt;
          &lt;td&gt;优先级&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VIRT&lt;/td&gt;
          &lt;td&gt;虚拟内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RES&lt;/td&gt;
          &lt;td&gt;内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SHR&lt;/td&gt;
          &lt;td&gt;共享内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME+&lt;/td&gt;
          &lt;td&gt;CPU使用累积时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把资源状态结果输出到文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -b -n 2 &amp;gt; /tmp/top.txt
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pstree&quot;&gt;pstree指令&lt;/h3&gt;

&lt;h4 id=&quot;pstree-1&quot;&gt;pstree参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;以ASCII字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-U&lt;/td&gt;
      &lt;td&gt;以UTF8字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;显示进程所属用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;显示进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;pstree-2&quot;&gt;pstree使用实例&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pstree -Uup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/linux/linux-pstree-Uup.png&quot; alt=&quot;pstree-Uup&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/linux-process-check/</link>
        <guid isPermaLink="true">/2016/03/30/linux-process-check/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Permutations(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations&quot; id=&quot;markdown-toc-permutations&quot;&gt;Permutations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations-ii&quot; id=&quot;markdown-toc-permutations-ii&quot;&gt;Permutations II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;permutations&quot;&gt;Permutations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,2,3] have the following permutations:&lt;/p&gt;

  &lt;p&gt;[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute( int[] nums ) {
    helperPermute( nums, 0 );
    return res;
}
private static void helperPermute( int[] nums, int t ) {
    if( t == nums.length ) {
        // 构造一个结果
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        
        // 加入结果集
        res.add( tmpRes );
    } else {
        for( int i = t; i &amp;lt; nums.length; ++i ) {
            swap( nums, t, i);
            helperPermute( nums, t+1 );
            swap( nums, t, i);
        }
    }
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个集合的全排列, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;排列树&lt;/code&gt;问题.&lt;/p&gt;

&lt;p&gt;代码可以这样理解, 集合S的全排列由以下的结果组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S[1]+全排列( S[2…n] )&lt;/li&gt;
  &lt;li&gt;S[2]+全排列( S[1, 3…n] )&lt;/li&gt;
  &lt;li&gt;S[3]+全排列( S[2, 1, 4…n] )&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;S[n]+全排列( S[1…n-1] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是把S的中每一个元素都提取到第一位, 剩下的元素做全排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 为什么要swap2次? 因为我们要保证在处理完一次结果之后, 要恢复数组的原始状态, 这样下一次处理的时候才能正确把下一个元素交换到第一个位置来.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的全排列&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个处理过程是迭代形式的, 而且迭代过程有严格的状态要求, 那么就十分需要注意子处理过程所带来的影响.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;permutations-ii&quot;&gt;Permutations II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

  &lt;p&gt;[1,1,2], [1,2,1], and [2,1,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique( int[] nums ) {
    Arrays.sort( nums );
    helperPermuteUnique( nums, 0, nums.length-1 );
    return res;
}
private static void helperPermuteUnique( int[] nums, int i, int j ) {
    if( i == j ) {
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        res.add( tmpRes );
    } 
    for( int k = i; k &amp;lt;= j; ++k ) {
        if( findSame(nums, i, k) ) continue;
        swap( nums, i, k );
        helperPermuteUnique( nums, i+1, j );
        swap( nums, i, k );
    }
}

private static boolean findSame( int[] nums, int i, int j ) {
    for( int k = i; k &amp;lt; j; ++k )
        if( nums[j] == nums[k] ) return true;
    return false;
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 对于有重复元素集合的全排列, 可以用上面无重复元素的全排列来解决, 区别就是我们在这个基础上还要排除一些重复的全排列, 那么我们需要思考的问题是: 按照无重复元素的全排列处理过程, 如何消除重复元素带来的影响? 我们知道全排列的一次处理过程就是把每一个元素都搬到第一个位置, 然后做剩余元素的全排列, 所以我们只需要判断当前元素跟前面的元素有没有重复, 有重复的话就是已经处理过的, 直接跳过.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型去思考问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-permutations(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-permutations(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Next Permutation</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically &amp;gt; next greater permutation of numbers.&lt;/p&gt;

  &lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible &amp;gt; order (ie, sorted in ascending order).&lt;/p&gt;

  &lt;p&gt;The replacement must be in-place, do not allocate extra memory.&lt;/p&gt;

  &lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding &amp;gt; outputs are in the right-hand column.&lt;/p&gt;

  &lt;p&gt;1,2,3 → 1,3,2&lt;/p&gt;

  &lt;p&gt;3,2,1 → 1,2,3&lt;/p&gt;

  &lt;p&gt;1,1,5 → 1,5,1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void nextPermutation( int[] nums ) {

    // 从后往前找到第一个递增对 [i, i+1]
    int i = nums.length-2;
    for( ; i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i+1]; --i );

    // 已经不存在递增对, 所有排列已经列举完了, 这里重新开始
    if( i &amp;lt; 0 ) {
        reverse( nums, 0, nums.length-1 );
        return;
    }

    // 从后往前找到第一个 [j] &amp;gt; [i]
    int j = nums.length-1;
    for( ; j &amp;gt; i &amp;amp;&amp;amp; nums[j] &amp;lt;= nums[i]; --j );

    // 构造下一个全排列
    swap( nums, i, j );
    i = i + 1;
    j = nums.length-1;
    reverse( nums, i, j );
}
private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
private static void reverse( int[] nums, int i, int j ) {
    while( i &amp;lt; j ) {
        swap( nums, i++, j-- );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个排列的下一个排列, 从数值上看, 就是找到下一个值, 使得下一个值&lt;code class=&quot;highlighter-rouge&quot;&gt;比当前值大&lt;/code&gt;并且要&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;. 所以我们可以从数值的低位部分入手, 因为改变低位对数值大小的影响最小, 也就满足了&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;这个条件. 现在考虑一个例子:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, … , A&lt;sub&gt;K&lt;/sub&gt;, A&lt;sub&gt;K+1&lt;/sub&gt;, …, A&lt;sub&gt;N&lt;/sub&gt;]&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;K+1&lt;/sub&gt; &amp;gt; … &amp;gt; A&lt;sub&gt;N&lt;/sub&gt; ( 1 &amp;lt; K &amp;lt; N, 也就是[K+1…N]递减 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于[K+1…N]这部分是递减的, 那么在这部分做修改是不可能构造出一个比当前值还大的值, 所以就要第[K]位加进来, 也就是对[K…N]这部分做修改, 那么该如何改呢?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在[K+1…N]中找一个刚好比[K]大的值, 与[K]交换, 才能构造出一个比当前值大的值, 所以就可以在[K+1…N]中由后往前找合适的值([K+1…N]是递减的, 所以由后往前找)&lt;/li&gt;
  &lt;li&gt;找到合适的值之后与[K]交换, 交换之后[K+1…N]还是递减的&lt;/li&gt;
  &lt;li&gt;修改[K+1…N]这部分变为最小值, 因为[K+1…N]是递减的, 翻转以下就可以了&lt;/li&gt;
  &lt;li&gt;得到下一个全排列的值&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 求下一个排列的问题可以转化为数值的问题, 然后又要想到数值的变化影响因素中, 低位的影响是最小的, 所以思考点要转移到如何修改低位部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;专注问题的思考点, 并且不断转换思考点, 直到问题清晰可解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-next-permutation/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-next-permutation/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>NQueens(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#nqueens&quot; id=&quot;markdown-toc-nqueens&quot;&gt;NQueens&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nqueens-ii&quot; id=&quot;markdown-toc-nqueens-ii&quot;&gt;NQueens II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nqueens&quot;&gt;NQueens&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such &amp;gt; that no two queens attack each other.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2012/03/8-queens.png&quot; alt=&quot;8-Queens&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;

  &lt;p&gt;Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.
For example,
There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueensRecursion( int n ) {
      List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      // 创建棋盘: board[i]表示第i行第board[i]列
      int[] board = new int[n];
      // 初始化棋盘, -1表示没有棋子
      Arrays.fill(board, -1);
      // 回溯查找解
      helperNQueens( 0, board, res );
      return res;
  }

  private static void helperNQueens(int t, int[] board, List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res) {
      if( t == board.length ) {
          res.add( newBoard(board) );
          return;
      }
      for( int i = 0; i &amp;lt; board.length; ++i ) {
          board[t] = i;
          if( constraints( board, t ) )
              helperNQueens( t+1, board, res );
      }
  }

  private static boolean constraints(int[] board, int t) {
      for( int i = 0; i &amp;lt; t; ++i ) {
          if( (board[i] == board[t]) ||
                  (t-i == board[t]-board[i] || t-i == board[i]-board[t]) )
              return false;
      }
      return true;
  }

  /*
   * 返回棋盘的表示形式, 类型为List&amp;lt;String&amp;gt;
   */
  private static List&amp;lt;String&amp;gt; newBoard(int[] board) {
      List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      int n = board.length;
      char[][] newBoard = new char[n][n];
      for( int i = 0; i &amp;lt; n; ++i )
          Arrays.fill(newBoard[i], &#39;.&#39;);
      for( int i = 0; i &amp;lt; n; ++i ) {
          newBoard[i][board[i]] = &#39;Q&#39;;
          StringBuilder sb = new StringBuilder();
          for( char c : newBoard[i] ) sb.append(c);
          res.add( sb.toString() );
      }
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考过程: N皇后问题属于经典的题目, 用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;来解决&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 难点主要有两个, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;棋盘的表示&lt;/code&gt;, 另一个是皇后之间的&lt;code class=&quot;highlighter-rouge&quot;&gt;冲突判断&lt;/code&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;棋盘的表示&lt;/code&gt;要建立在对问题约束条件的理解之上. 棋盘之中皇后之间不能处于同一行, 也不能处于同一列, 那么我们可以用一个数组board来表示这个棋盘.&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;数组下标表示棋盘中的行值&lt;/li&gt;
        &lt;li&gt;数组的值表示棋盘中的列值&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;冲突判断&lt;/code&gt;有3个条件:&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;皇后不能处于同一行: 不需要显示判断, 因为我们以行作为递归, 皇后不可能出现在同一行&lt;/li&gt;
        &lt;li&gt;皇后不能处于同一列: 根据 board[i] == board[j] 作为判断&lt;/li&gt;
        &lt;li&gt;皇后不能处于同一斜线: 根据 j-i == abs(board[j]-board[i]) (j&amp;gt;i)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;斜线的判断可能比较难以理解: 意思是行值差与列值差相等表示皇后在同一斜线上.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的棋盘&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;善于观察题目的限制条件, 从而构造出合适的数据结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueensIteration( int n ) {
      List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      // 创建棋盘: board[i]表示第i行第board[i]列
      int[] board = new int[n];

      // 初始化第0行的状态
      board[0] = -1;
      // t表示目前处于第t行
      int t = 0;
      while( t &amp;gt;= 0 ) {
          // 查找第t行皇后的存放位置
          ++board[t];
          while( board[t] &amp;lt; n &amp;amp;&amp;amp; !constraints( board, t ) ) ++board[t];

          // 找到第t行皇后的存放位置就进入下一行
          if( board[t] &amp;lt; n ) {
              if( t == n-1 ) {
                  res.add( newBoard(board) );
              } else {
                  ++t;
                  board[t] = -1;
              }
          } else {
              --t;
          }
      }
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;nqueens-ii&quot;&gt;NQueens II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;

  &lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.
&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2012/03/8-queens.png&quot; alt=&quot;8-Queens&quot; /&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;该题目的算法与上一道题的一模一样, 只需要在相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;递归版本&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;迭代版本&lt;/code&gt;中找到可行解的时候统计数量即可&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-NQueens(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-NQueens(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Subsets(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets&quot; id=&quot;markdown-toc-subsets&quot;&gt;Subsets&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets-ii&quot; id=&quot;markdown-toc-subsets-ii&quot;&gt;Subsets II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subsets&quot;&gt;Subsets&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,3], a solution is:
    [
      [3],
      [1],
      [2],
      [1,2,3],
      [1,3],
      [2,3],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsRecursion( int[] nums ) {
      Arrays.sort( nums );
      helperRecursion( nums, 0, new ArrayList&amp;lt;Integer&amp;gt;() );
      return res;
  }
  private static void helperRecursion( int[] nums, int t, List&amp;lt;Integer&amp;gt; tmpRes ) {
      // 获得一个子集
      if( t == nums.length ) {
          res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
          return;
      }
      // 不选择当前深度的节点
      helperRecursion( nums, t+1, tmpRes );

      // 选择当前深度的节点
      tmpRes.add( nums[t] );
      helperRecursion( nums, t+1, tmpRes );
      tmpRes.remove( tmpRes.size()-1 );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 求一个集合的所有子集, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;子集树&lt;/code&gt;问题, 而且这棵树是一棵完全二叉树, 利用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的递归写法可以很容易的写出代码.&lt;/p&gt;

    &lt;p&gt;处理过程: 利用一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;表示当前树的深度, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;深度的时候, 有两种选择, 一种是不选择当前深度的节点并且进入下一层, 另一种是选择当前深度的节点并且进入下一层. 其终止条件就是到达叶子节点.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetIteration( int[] nums ) {
      Arrays.sort( nums );
      List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        
      // 初始状态: 结果集中包含了子集: 空集
      res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
        
      // 构造过程: 动态生成每一个子集并且加入结果集
      for( int i = 0; i &amp;lt; nums.length; ++i ) {
          int subsetCount = res.size();
          for( int j = 0; j &amp;lt; subsetCount; ++j ) {
              List&amp;lt;Integer&amp;gt; newSubset = new ArrayList&amp;lt;&amp;gt;( res.get(j) );
              newSubset.add( nums[i] );
              res.add( newSubset );
          }
      }
        
      // 结束状态: 返回结果集
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 在思考问题解之前, 可以先思考另外一个问题: 对结果集产生影响的基本因素是什么? 基本因素就是数组中的元素. 再思考一个问题: 基本因素是如何影响结果集的? 当原本数组加入一个新的元素的时候, 由于元素在子集中可选可不选, 不选的话不会对原本的结果集产生影响, 选择的话原本的结果集会多添加一些新子集, 而且这些新子集=旧子集+新元素&lt;/p&gt;

    &lt;p&gt;处理过程: 首先, 对于任何的数组, 其结果集中一定有一个空集; 之后对每一个元素, 产生一些新子集: 新子集=旧子集+新元素, 并且把新子集加入结果集中; 最后返回结果集.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度O(2^n), 空间复杂度O(1): 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于有处理模型的问题, 我们很容易想到解决方案; 但是有时候我们并不知道处理模型是什么, 我们应该从小方面入手, 思考问题的基本因素, 从基本因素展开分析, 从而构造出一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;subsets-ii&quot;&gt;Subsets II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,2], a solution is:
    [
      [2],
      [1],
      [1,2,2],
      [2,2],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsIteration( int[] nums ) {
    Arrays.sort( nums );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
    // 初始状态: 结果集中包含了子集: 空集
    res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
    
    // 构造过程: 对每一个元素构造出新子集并加入结果集
    for( int i = 0; i &amp;lt; nums.length; ) {
        // 统计重复个数
        int repeatNum = 0;
        while( i+repeatNum &amp;lt; nums.length &amp;amp;&amp;amp;
                nums[i] == nums[repeatNum+i] ) ++repeatNum;
        // 构造子集
        int subsetCount = res.size();
        for( int j = 0; j &amp;lt; subsetCount; ++j ) {
            List&amp;lt;Integer&amp;gt; subset = new ArrayList&amp;lt;Integer&amp;gt;( res.get(j) );
            for( int k = 0; k &amp;lt; repeatNum; ++k ) {
                subset.add( nums[i] );
                res.add( new ArrayList&amp;lt;Integer&amp;gt;( subset ) );
            }
        }
        i += repeatNum;
    }
    
    // 结束状态: 返回结果集
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 其基本思考过程同上面的Subsets迭代方式差不多, 不同点在于出现了重复元素, 那么还是一样, 我们思考重复元素对原始结果集的影响是什么? 思考这样一个例子[ 1, 2, 2 ], 当处理完元素[1]的时候, 我们得到的结果集是{ {}, {1} }, 接下来对于重复元素[2], 我们可以构造出来的新子集=旧子集+(1或2)个[2], 也就是说, 对于重复元素, 我们可以选择1-n个重复元素加入旧子集形成新子集, 对于重复元素的解决方案就出来了, 最后可以得到上面的代码&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;还是一样, 对于一个新的问题, 我们应该从基本的角度去思考, 从而展开到一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/29/leetcode-subsets(II)/</link>
        <guid isPermaLink="true">/2016/03/29/leetcode-subsets(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>find指令学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#find&quot; id=&quot;markdown-toc-find&quot;&gt;find指令的用途&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#find-1&quot; id=&quot;markdown-toc-find-1&quot;&gt;find指令常用参数说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#find-2&quot; id=&quot;markdown-toc-find-2&quot;&gt;find指令常用例子&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;查找前5个最大的文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;查找某一段时间修改过的文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;在多个目录中查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;排除指定目录查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;按照文件类型查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;重复文件查找&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find&quot;&gt;find指令的用途&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在目录层次中查找满足特定要求的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;find-1&quot;&gt;find指令常用参数说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-type c: 按照文件类型c查找, 文件类型c说明如下:
    &lt;ul&gt;
      &lt;li&gt;b: 块设备文件&lt;/li&gt;
      &lt;li&gt;c: 字符设备文件&lt;/li&gt;
      &lt;li&gt;d: 目录&lt;/li&gt;
      &lt;li&gt;p: 管道文件&lt;/li&gt;
      &lt;li&gt;f: 普通文件&lt;/li&gt;
      &lt;li&gt;l: 符号链接文件&lt;/li&gt;
      &lt;li&gt;s: 套接字文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-name fname: 按照fname(不加目录前缀)查找文件&lt;/li&gt;
  &lt;li&gt;-exec command: 对查找到的文件进行指令处理, 注意结尾以’;’结束&lt;/li&gt;
  &lt;li&gt;-mmin n: 查找n分钟之前修改过的文件&lt;/li&gt;
  &lt;li&gt;-mtime n: 查找n天之前修改过的文件&lt;/li&gt;
  &lt;li&gt;-xdev: 只查找当前的文件系统&lt;/li&gt;
  &lt;li&gt;-printf: 如果find指令返回值为true, 指定格式输出结果&lt;/li&gt;
  &lt;li&gt;-prune: 排除指定的搜索范围&lt;/li&gt;
  &lt;li&gt;-o: 或者&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;find-2&quot;&gt;find指令常用例子&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;查找前5个最大的文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -type f -exec du {} \; | sort -n | tail -n 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-exec du表示对每一个找到的文件都计算文件大小&lt;/p&gt;

  &lt;p&gt;sort -n表示对所有文件按大小升序排序&lt;/p&gt;

  &lt;p&gt;tail -n 5表示取最后5个文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;查找某一段时间修改过的文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -mmin +60 -mmin -120 -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-mmin +60: 表示前60分钟之前&lt;/p&gt;

  &lt;p&gt;-mmin -120: 表示前120分钟之后&lt;/p&gt;

  &lt;p&gt;所以该指令就是查找2个小时之前的1小时内修改过的文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;在多个目录中查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find /etc /var /mnt /media -xdev -mmin -5 -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令在/etc, /var, /mnt, /media这些目录下查找&lt;/p&gt;

  &lt;p&gt;-xdev表示只对该文件系统查找&lt;/p&gt;

  &lt;p&gt;-mmin -5 表示5分钟之内修改过的文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;排除指定目录查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / \( -name proc -o -name sys \) -prune -o -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示对根目录查找, 但是排除 /proc 和 /sys这两个目录&lt;/p&gt;

  &lt;p&gt;-prune -o表示对满足括号中条件的目录排除在外&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;按照文件类型查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -name &quot;*.png&quot; -o -name &quot;*.jpg&quot; -o -name &quot;*.gif&quot; -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示在当前目录中查找格式为png, jpg, gif的文件&lt;/p&gt;

  &lt;p&gt;-o 表示或者&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-5&quot;&gt;重复文件查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type f -exec md5sum &#39;{}&#39; &#39;;&#39; | sort | uniq --all-repeated=separate -w 24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示对当前目录下的文件计算MD5并通过前24位进行比较&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/28/linux-command-find/</link>
        <guid isPermaLink="true">/2016/03/28/linux-command-find/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>IP原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ip&quot; id=&quot;markdown-toc-ip&quot;&gt;IP地址分类&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-1&quot; id=&quot;markdown-toc-ip-1&quot;&gt;IP地址编址历史&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-2&quot; id=&quot;markdown-toc-ip-2&quot;&gt;IP地址分类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-3&quot; id=&quot;markdown-toc-ip-3&quot;&gt;IP常用地址&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-4&quot; id=&quot;markdown-toc-ip-4&quot;&gt;特殊IP地址&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-5&quot; id=&quot;markdown-toc-ip-5&quot;&gt;IP地址与硬件地址&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-6&quot; id=&quot;markdown-toc-ip-6&quot;&gt;IP地址与硬件地址的原理区别&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#arp&quot; id=&quot;markdown-toc-arp&quot;&gt;ARP协议&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-7&quot; id=&quot;markdown-toc-ip-7&quot;&gt;IP数据报格式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-8&quot; id=&quot;markdown-toc-ip-8&quot;&gt;IP首部格式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;报文段切割&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-9&quot; id=&quot;markdown-toc-ip-9&quot;&gt;IP层转发分组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip&quot;&gt;IP地址分类&lt;/h3&gt;

&lt;p&gt;IP地址唯一标识网络中某一个设备, 其定义如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP ::= { 网络号 : 主机号 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ip-1&quot;&gt;IP地址编址历史&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;分类编址: IP地址可以划分为ABCDE五类, 可以参考下图&lt;/li&gt;
  &lt;li&gt;划分子网: 在分类编址的基础上定义了子网的概念和划分原理&lt;/li&gt;
  &lt;li&gt;无分类编址: 抛弃分类编址的方式, 重新定义编址方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ip-2&quot;&gt;IP地址分类&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-classification.jpg&quot; alt=&quot;IP分类编址&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ip-3&quot;&gt;IP常用地址&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-use-usually-classification.gif&quot; alt=&quot;IP常用地址&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;A类地址中减去2表示排除了网络号全0(表示&lt;code class=&quot;highlighter-rouge&quot;&gt;本网络&lt;/code&gt;)和网络号127(表示&lt;code class=&quot;highlighter-rouge&quot;&gt;环回地址&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;B类地址中减去1表示排除了128.0(保留)网络&lt;/li&gt;
    &lt;li&gt;C类地址中减去1表示排除了192.0.0(保留)网络&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ip-4&quot;&gt;特殊IP地址&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-use-rarely.jpg&quot; alt=&quot;特殊IP地址&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-5&quot;&gt;IP地址与硬件地址&lt;/h3&gt;

&lt;p&gt;IP地址唯一表示网络中的某一个设备, 硬件地址也是唯一表示某一个设备, 那么为什么需要两种地址呢?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是因为全世界有着各种各样的网络, 不同的网络使用不同的硬件地址, 为了使得这些异构网络之间能够通信, 就需要一个统一的规则来表示每个设备, 也就是IP地址了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ip-6&quot;&gt;IP地址与硬件地址的原理区别&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-ipAddress-and-macAddress.jpg&quot; alt=&quot;IP地址与硬件地址的原理区别&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;arp&quot;&gt;ARP协议&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ARP协议&lt;/code&gt;是用来找出IP地址对应的硬件地址, 还有一个协议是&lt;code class=&quot;highlighter-rouge&quot;&gt;RARP协议&lt;/code&gt;, 是用来找出硬件地址对应的IP地址, 这两个协议都是处于网络层中&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ARP协议&lt;/code&gt;的工作原理如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-arp.jpg&quot; alt=&quot;ARP协议的工作原理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ARP工作原理解释如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主机A在局域网中广播ARP请求分组&lt;/li&gt;
  &lt;li&gt;所有主机都受到ARP请求分组, 但是只有主机B响应分组&lt;/li&gt;
  &lt;li&gt;主机A收到主机B的响应分组, 在ARP高速缓存中记录主机B&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;主机A发送出ARP请求分组, 主机B会在ARP高速缓存中记录主机A, 这样可以避免主机B要找主机A的时候也要发出一个ARP请求分组, 减少了网络开销&lt;/li&gt;
    &lt;li&gt;ARP高速缓存中的记录是有生存时间的, 过了生存时间的记录就会自动删除, 这是基于网络中的硬件地址是动态变更这种情况考虑的, 例如主机B换了一个网络适配器, 其先前的地址也就无效了&lt;/li&gt;
    &lt;li&gt;ARP协议是解决同一个局域网内的主机中IP地址与硬件地址的映射问题&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-7&quot;&gt;IP数据报格式&lt;/h3&gt;

&lt;h4 id=&quot;ip-8&quot;&gt;IP首部格式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-header.jpg&quot; alt=&quot;IP数据报格式&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;版本: IP协议版本(IPv4, IPv6等)&lt;/li&gt;
  &lt;li&gt;首部长度: IP首部的字节长度, 范围为20~60&lt;/li&gt;
  &lt;li&gt;区分服务: 更多服务&lt;/li&gt;
  &lt;li&gt;总长度: IP数据报的长度, 范围为20~65535字节, 一般以太网使用的MTU(Maximum Transfer Unit)为1500, MTU表示IP数据报中数据部分的最大长度&lt;/li&gt;
  &lt;li&gt;标识: 报文段发生分片的时候使用, 接收端通过标识可以合并同一个标识的IP数据报&lt;/li&gt;
  &lt;li&gt;标志: 目前使用DF(Don’t Fragment)和MF(More Fragment)&lt;/li&gt;
  &lt;li&gt;片偏移: IP数据报合并时, 用来确认每一个IP数据报在原始报文段中的位置, 8个字节为单位&lt;/li&gt;
  &lt;li&gt;生存时间: IP数据报的生存时间, 目前一般表示跳数&lt;/li&gt;
  &lt;li&gt;协议: 表示IP数据报使用的协议, 例如: TCP, UDP, OSPF&lt;/li&gt;
  &lt;li&gt;首部检验和: 检验IP首部, 每一次路由转发后, 都会检验首部的正确性&lt;/li&gt;
  &lt;li&gt;源地址: 发送方IP地址&lt;/li&gt;
  &lt;li&gt;目的地址: 接收方IP地址&lt;/li&gt;
  &lt;li&gt;可选字段(长度可变)&lt;/li&gt;
  &lt;li&gt;填充: IP首部填充0, 知道满足以4个字节为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;报文段切割&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-data-split.png&quot; alt=&quot;IP数据报分片举例&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;解释如下:
原始题目中规定IP数据报的&lt;code class=&quot;highlighter-rouge&quot;&gt;MTU&lt;/code&gt;为1400, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;是以8个字节为单位, 我们发现8能够整除1400, 所以我们可以直接以1400个字节为切割单位, 分别切割出1400/1400/1000这样的3个数据, 然后分别计算&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;, 得到0/175/350, 这样把这些数据写到各自的首部中, 另外还需要给这3个数据一个共同的&lt;code class=&quot;highlighter-rouge&quot;&gt;标识&lt;/code&gt;(例如:12345).&lt;/p&gt;

  &lt;p&gt;这样切割之后, 接收端就可以根据&lt;code class=&quot;highlighter-rouge&quot;&gt;标识&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;来组合IP数据报, 得到原始的报文段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-9&quot;&gt;IP层转发分组&lt;/h3&gt;

&lt;p&gt;转发分组涉及两个概念: &lt;code class=&quot;highlighter-rouge&quot;&gt;路由&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;路由 ::= ( 目的网络地址, 下一跳地址 )
路由表 ::= 包含路由信息的表格
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个IP数据报的转发都需要查询&lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-transfer-algorithm.jpg&quot; alt=&quot;IP层转发分组&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分组转发算法流程如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;从IP数据报首部中提取目的IP地址D, 并计算得到网络地址N&lt;/li&gt;
    &lt;li&gt;如果N就是与路由器直接相连的网络, 那么直接交付到目的主机, 否则执行(3)&lt;/li&gt;
    &lt;li&gt;如果路由表中有目的地址D的特定主机路由, 那么交付特定路由器, 否则执行(4)&lt;/li&gt;
    &lt;li&gt;如果路由表中有目的网络N的转发地址, 那么交付对应的路由器, 否则执行(5)&lt;/li&gt;
    &lt;li&gt;如果路由表中有默认路由, 那么交付默认路由器, 否则执行(6)&lt;/li&gt;
    &lt;li&gt;报告转发分组出错&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/27/computer-network-ip/</link>
        <guid isPermaLink="true">/2016/03/27/computer-network-ip/</guid>
        
        
        <category>计算机网络</category>
        
      </item>
    
      <item>
        <title>回溯法原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;回溯法定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;回溯法原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;回溯法算法框架&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;递归回溯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;迭代回溯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;子集树&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;排列树&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;回溯法定义&lt;/h3&gt;

&lt;p&gt;回溯法是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;搜索算法&lt;/code&gt;, 可以系统地搜索一个问题的&lt;code class=&quot;highlighter-rouge&quot;&gt;所有解&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;任一解&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回溯法原理&lt;/h3&gt;

&lt;p&gt;回溯法的搜索原理是&lt;code class=&quot;highlighter-rouge&quot;&gt;深度优先搜索策略&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原理: &lt;strong&gt;首先定义问题的解空间&lt;/strong&gt;, 举个&lt;code class=&quot;highlighter-rouge&quot;&gt;0-1背包&lt;/code&gt;的例子, 假设只有两个东西, 那么解空间可以这样表示{(00),(01),(10),(11)}; &lt;strong&gt;其次组织解空间, 一般组织为树或者图&lt;/strong&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;0-1背包&lt;/code&gt;的解空间就变成了一棵完全二叉树; &lt;strong&gt;最后是开始搜索&lt;/strong&gt;, 过程是这样的: 从根节点出发, 以深搜方式搜索整个解空间. 根节点首先成为&lt;code class=&quot;highlighter-rouge&quot;&gt;活节点&lt;/code&gt;, 并且纵向移至下一个新节点, 新节点就成为了&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;无法再纵向移动, 那么就成为了&lt;code class=&quot;highlighter-rouge&quot;&gt;死节点&lt;/code&gt;, 此时就应该回溯到最近一个&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;处, 继续用以上的方式进入下一个扩展.&lt;/p&gt;

&lt;p&gt;回溯法以这种方式在解空间中搜索, 直到找到所要求的解活解空间中已经没有&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;为止&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法的步骤如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;针对所给问题, 定义问题的解空间&lt;/li&gt;
    &lt;li&gt;确定易于搜索的解空间结构&lt;/li&gt;
    &lt;li&gt;以深搜方式搜索解空间, 并在搜索过程中使用剪枝函数避免无效搜索&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;回溯法算法框架&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;递归回溯&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            x[ t ] = h( i );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;t 表示递归深度&lt;/li&gt;
    &lt;li&gt;n 表示解空间树的总深度&lt;/li&gt;
    &lt;li&gt;x 表示可行解&lt;/li&gt;
    &lt;li&gt;f(n,t) 表示当前&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;未搜索过的子树起始编号&lt;/li&gt;
    &lt;li&gt;g(n,t) 表示当前&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;未搜索过的子树终止编号&lt;/li&gt;
    &lt;li&gt;constraint(t) 表示约束函数, 用于确认x[1…t]是否满足约束条件, 不满足条件可以剪枝&lt;/li&gt;
    &lt;li&gt;bound(t) 表示限界函数, 用于确认x[1…t]是否使目标函数越界, 使目标函数越界可以剪枝&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;迭代回溯&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void iterativeBackTrack() {
    int t = 1;
    while( t &amp;gt; 0 ) {
        if( f( n, t ) &amp;lt;= g( n, t ) ) {
            for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
                x[ t ] = h( i );
                if( constraint( t ) &amp;amp;&amp;amp; bound( t ) ) {
                    if( solution( t ) )	//表示有可行解
                        Output( x );
                    else
                        ++t;
                }
            }
        } else {
            --t;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;子集树&lt;/h4&gt;

&lt;p&gt;子集树定义:当所给的问题是从n个元素的集合中找出满足某种性质的子集时, 相应的解空间树称为子集树, 其解空间大小为O(2^n)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            x[ t ] = h( i );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;排列树&lt;/h4&gt;

&lt;p&gt;排列树定义:当所给的问题是从n个元素的集合中找出满足某种性质的排列时, 相应的解空间树称为排列树, 其解空间大小为O(n!)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            // swap表示交换元素
            swap( x[t], x[i] );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
            swap( x[t], x[i] );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/27/algorithm-backtracking/</link>
        <guid isPermaLink="true">/2016/03/27/algorithm-backtracking/</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>TCP原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp&quot; id=&quot;markdown-toc-tcp&quot;&gt;TCP概述&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tcp-1&quot; id=&quot;markdown-toc-tcp-1&quot;&gt;TCP特点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tcp-2&quot; id=&quot;markdown-toc-tcp-2&quot;&gt;TCP连接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-3&quot; id=&quot;markdown-toc-tcp-3&quot;&gt;TCP报文段&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-4&quot; id=&quot;markdown-toc-tcp-4&quot;&gt;TCP可靠传输&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;滑动窗口&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;超时重传&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;选择确认&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-5&quot; id=&quot;markdown-toc-tcp-5&quot;&gt;TCP流量控制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-6&quot; id=&quot;markdown-toc-tcp-6&quot;&gt;TCP拥塞控制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;拥塞控制原理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;拥塞控制方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-7&quot; id=&quot;markdown-toc-tcp-7&quot;&gt;TCP连接管理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;建立连接&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;释放连接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcp&quot;&gt;TCP概述&lt;/h3&gt;

&lt;h4 id=&quot;tcp-1&quot;&gt;TCP特点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;面向连接: 在连接的基础上双方才可以通信&lt;/li&gt;
  &lt;li&gt;端到端: 通信只有两个端点&lt;/li&gt;
  &lt;li&gt;可靠交付: 传输什么样的数据, 就接受什么样的数据&lt;/li&gt;
  &lt;li&gt;全双工通信: 通信是双向的, 而且不会相互干扰&lt;/li&gt;
  &lt;li&gt;面向字节流: 数据以字节传输, 表明TCP不知道数据的含义&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tcp-2&quot;&gt;TCP连接&lt;/h4&gt;

&lt;p&gt;什么是TCP连接? TCP连接就是一个抽象表示, 指出了通信双方的身份.&lt;/p&gt;

&lt;p&gt;通信中的一方我们用套接字(socket)表示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;套接字socket = ( IP地址: 端口号 )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而且我们知道TCP连接是&lt;code class=&quot;highlighter-rouge&quot;&gt;端到端&lt;/code&gt;的, 所以TCP连接可以这样表示:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP连接 ::= { socket1, socket2 } = { (IP1: port1), (IP2: port2) }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-3&quot;&gt;TCP报文段&lt;/h3&gt;

&lt;p&gt;TCP报文段的组成很简单, 只有首部和数据, 表示如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP报文段 ::= TCP首部 + 数据部分
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TCP首部信息如下图所示(注:数字表示位数):
&lt;img src=&quot;\assets\computer-network\tcp-header.png&quot; alt=&quot;TCP首部信息&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首部信息中各字段解释如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;源端口: 发送方port, 可知端口范围为0~65535&lt;/li&gt;
  &lt;li&gt;目的端口: 接收方port, 可知端口范围为0~65535&lt;/li&gt;
  &lt;li&gt;序号: 报文段的编号, 可知序号范围0~2^32^-1, 由于TCP是面向字节流的,所以一个序号表示一个字节&lt;/li&gt;
  &lt;li&gt;确认号: 告知对方自己期望的下一个报文段编号&lt;/li&gt;
  &lt;li&gt;数据偏移: TCP首部长度, 表示到达数据部分的偏移量, 范围为0~15, 所以首部长度最多为60字节&lt;/li&gt;
  &lt;li&gt;保留: 未定义&lt;/li&gt;
  &lt;li&gt;URG: 紧急位, 用于设置紧急指针&lt;/li&gt;
  &lt;li&gt;ACK: 确认位, 用于设置确认号&lt;/li&gt;
  &lt;li&gt;PSH: 推送位, 告知TCP数据发送&lt;/li&gt;
  &lt;li&gt;RST: 重置位, 告知对方TCP出现错误,需要重新连接&lt;/li&gt;
  &lt;li&gt;SYN: 同步位, 建立连接的标志&lt;/li&gt;
  &lt;li&gt;FIN: 结束位, 释放连接的标志&lt;/li&gt;
  &lt;li&gt;窗口: 告知对方自己的接受窗口&lt;/li&gt;
  &lt;li&gt;检验和: 检验TCP报文段的有效性, 包括TCP首部和数据部分&lt;/li&gt;
  &lt;li&gt;紧急指针: URG置1有效, 定位紧急数据&lt;/li&gt;
  &lt;li&gt;选项(长度可变): 用于扩展TCP首部信息&lt;/li&gt;
  &lt;li&gt;填充: 填充TCP首部格式使得满足以4字节为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP报文段的规则中定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;MSS&lt;/code&gt;(Maximum Segment Size:最大报文段长度), 表示TCP报文段中数据部分的最大长度, 默认值是536, 所以因特网中的所有主机都应能够接受536+20=556字节的最大报文段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-4&quot;&gt;TCP可靠传输&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;可靠传输&lt;/strong&gt;有三个方面的含义:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无差错: 数据传输之前之后是一样的&lt;/li&gt;
  &lt;li&gt;不丢失: 发送方发送的数据, 接收方一定可以接收到&lt;/li&gt;
  &lt;li&gt;不重复: 发送方发送的数据, 接收方不会重复接受&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;滑动窗口&lt;/h4&gt;

&lt;p&gt;滑动窗口是基于字节流的, 所以滑动的单位为1字节, 其结构如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-sliding-window.png&quot; alt=&quot;滑动窗口结构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说明如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Category #1: 已发送, 已确认&lt;/li&gt;
  &lt;li&gt;Category #2: 已发送, 未确认&lt;/li&gt;
  &lt;li&gt;Category #3: 未发送, 可发送&lt;/li&gt;
  &lt;li&gt;Category #4: 未发送, 不可发送&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意的细节问题:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;发送窗口可能要比接受窗口小, 因为发送方要考虑网络拥塞问题&lt;/li&gt;
    &lt;li&gt;对于不按序到达的数据如何处理, TCP标准没有说明. 但是考虑网络资源的珍贵性, 一般情况下接收方都会接受下来暂时保存着&lt;/li&gt;
    &lt;li&gt;接收方必须要有累计确认的功能, 因为这样可以很好的减小开销&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;超时重传&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;超时重传&lt;/strong&gt;是为了保证可靠传输, 其实现涉及两个东西: &lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;(Round-Time Trip)和&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;(Retransmission Time-Out).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;: 报文段往返时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;: 超时重传时间, 略大于&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个报文段发送出去, 如果过了&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;时间还没有接收到确认, 那么就需要重传报文段&lt;/p&gt;

&lt;p&gt;我们知道网络情况是动态的, 有时候网络良好, 有时候网络拥塞, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;就应该也是动态变化的,&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;自然而然也就跟着&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;动态变化. 这个动态变化就需要设计一个算法来计算, 我们这里就简单讲一下3个算法.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;自适应算法:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RTTs = (1-a)*(旧RTTs) + a*(新RTT样本)
  RTO = RTTs + 4*RTTD (注:RTTD表示RTT偏差加权平均值)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Karn算法: 在自适应算法基础上, 提出只要报文段重传, 那么就不采用其样本RTT&lt;/li&gt;
  &lt;li&gt;Karn修正算法: 在Karn算法基础上, 剔除只要报文段重传, 那么RTO就增大一点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;选择确认&lt;/h4&gt;

&lt;p&gt;SAK(Selective ACK)选择确认是指在发生数据未按序到达的时候, 接收方告诉发送方自己接收了哪些数据, 从而发送发可以决定重发丢失的数据, 而不是全部重新重发, 使得网络资源得到更好的利用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SAK的实现原理是借助TCP首部信息中的&lt;code class=&quot;highlighter-rouge&quot;&gt;选项(可选长度)&lt;/code&gt;这一部分. 我们知道一个连续的字节段可以由头序号和尾序号表示, 一个序号需要4个字节, 所以一个字节段需要8个字节表示, 那么我们是不是一次告诉发送方5个字节段呢?(首部最长60字节,20字节是固定的,所以有&lt;code class=&quot;highlighter-rouge&quot;&gt;40字节/8字节=5&lt;/code&gt;). 然而并没有, 因为还需要2个字节, 分别表明使用SAK选项和选项长度, 所以只有40-2=38个字节可用, 所以一次最多告诉发送方4个字节段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-5&quot;&gt;TCP流量控制&lt;/h3&gt;

&lt;p&gt;所谓流量控制, 就是接收方让发送方不要发送太多的数据, 好让接收方来得及接受, 过程如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-flow-control.jpg&quot; alt=&quot;TCP流量控制&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出, 接收方一共进行了3次流量控制&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 现在考虑一种情况, 在上图中, 接下来B处理完了缓冲区的数据, 那么B就会发送一个rwnd=400的报文段, 然而报文段却在中途丢失了, 那么A就一直等B的通知, 而B也一直等A发数据, 因为B认为自己已经通知A可以发送了, 这样就形成了一个死锁.
所以TCP为每一个连接都设置了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;持续计时器&lt;/code&gt;, 每当接收方得知发送方的发送窗口值为0的时候, 启动&lt;code class=&quot;highlighter-rouge&quot;&gt;持续计时器&lt;/code&gt;, 时间一到接收方就发送一个&lt;code class=&quot;highlighter-rouge&quot;&gt;探测报文段&lt;/code&gt;, 一直持续这个过程直到发送方的发送窗口不为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tcp-6&quot;&gt;TCP拥塞控制&lt;/h3&gt;

&lt;p&gt;所谓拥塞控制, 就是防止过多的数据注入到网络中, 使得网络中的路由器或链路不致过载&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 拥塞控制不同于流量控制, 拥塞控制是基于整个网络考虑, 而流量控制是基于通信双方考虑&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;拥塞控制原理&lt;/h4&gt;

&lt;p&gt;拥塞控制从大方面考虑可以分为两种: &lt;code class=&quot;highlighter-rouge&quot;&gt;开环控制&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;开环控制&lt;/code&gt;是指在网络设计的时候把相关拥塞因素考虑进来, 一旦网络运行起来就不变更了; &lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;则是动态地考虑拥塞情况并做出控制, 我们这里讲一下&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;的原理&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;是基于反馈环路的概念.属于&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;有以下几步&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检测网络系统得知拥塞发生的时间地点&lt;/li&gt;
  &lt;li&gt;把拥塞信息发送到可以采取行动的地方&lt;/li&gt;
  &lt;li&gt;调整网络系统的运行以解决拥塞问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-4&quot;&gt;拥塞控制方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;慢开始(slow-start): 从发送数据开始, 拥塞窗口逐渐增大&lt;/li&gt;
  &lt;li&gt;拥塞避免(congestion avoidance): 从感知到拥塞开始, 拥塞窗口缓慢增大&lt;/li&gt;
  &lt;li&gt;快重传(fast retransmit): 从丢失报文段开始, 不断重复确认丢失报文段, 使得尽快重传报文段&lt;/li&gt;
  &lt;li&gt;快恢复(fast recovery): 从发现快重传开始, 缩小一半拥塞窗口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;慢开始&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;拥塞避免&lt;/code&gt;一起使用, &lt;code class=&quot;highlighter-rouge&quot;&gt;快重传&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;快恢复&lt;/code&gt;一起使用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;慢开始&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;拥塞避免&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-slow-start-and-congestion-avoidance.jpg&quot; alt=&quot;慢开始和拥塞避免&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;快重传&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;快恢复&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-fast-retransmit-fast-recovery.jpg&quot; alt=&quot;快重传和快恢复&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;ssthresh是指慢开始门限, 也就是慢开始算法切换掉的分割线&lt;/li&gt;
    &lt;li&gt;慢开始算法的拥塞窗口起始值是1&lt;/li&gt;
    &lt;li&gt;发送方窗口上限值 = Min [ rwnd, cwnd ]&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-7&quot;&gt;TCP连接管理&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;建立连接&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-link-create.png&quot; alt=&quot;TCP建立连接&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里为什么需要三次握手, 而不是两次握手呢?&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;主要是从服务端角度考虑, 目的是为了不浪费服务端资源&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;考虑两次握手的情景, 客户端发送了请求连接(1), 但是延迟了, 于是客户端再发送一次请求连接(2), 并且完成了通信和释放了连接(2), 之后服务端收到了连接(1)并建立连接, 但是客户端已经不需要连接(1)了, 所以连接(1)会造成服务端网络资源的浪费&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;但是使用三次握手会引来另外一个问题: 客户端资源的浪费&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;主要是因为客户端发送第三次握手过后, 客户端就可以发送数据了, 但是连接是否建立成功还不一定, 所以就有可能造成客户端资源的浪费&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-6&quot;&gt;释放连接&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-link-release.gif&quot; alt=&quot;TCP建立连接&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP连接建立和释放过程中, 每一步报文段分别发生丢失我们要怎么处理呢?&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;关键在于理解: 无论客户端还是服务端, 只要是状态变更的发起者, 那么就要负责重传服务&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;例如1: 在TCP连接建立过程中, 客户端从CLOSED到SYN-SENT, 状态发生变更发起者是客户端, 客户端就要负责失败重传; 服务端从LISTEN到SYN-RCVD, 状态发生变更发起者是服务器, 服务端要负责失败重传&lt;/p&gt;

  &lt;p&gt;例如2:在TCP连接释放过程中, 客户端从ESTABLISHED到FIN-WAIT1, 状态发生变更发起者是客户端, 客户端份负责重传; 服务端从CLOSE-WAIT到LAST-ACK, 状态发生变更发起者是服务端, 服务端负责重传&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 26 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/26/computer-network-tcp/</link>
        <guid isPermaLink="true">/2016/03/26/computer-network-tcp/</guid>
        
        
        <category>计算机网络</category>
        
      </item>
    
  </channel>
</rss>
