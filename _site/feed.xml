<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SCH</title>
    <description>苏灿灏的博客 大数据爱好者</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 30 Mar 2016 16:42:06 +0800</pubDate>
    <lastBuildDate>Wed, 30 Mar 2016 16:42:06 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Permutations(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations&quot; id=&quot;markdown-toc-permutations&quot;&gt;Permutations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations-ii&quot; id=&quot;markdown-toc-permutations-ii&quot;&gt;Permutations II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;permutations&quot;&gt;Permutations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,2,3] have the following permutations:&lt;/p&gt;

  &lt;p&gt;[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute( int[] nums ) {
    helperPermute( nums, 0 );
    return res;
}
private static void helperPermute( int[] nums, int t ) {
    if( t == nums.length ) {
        // 构造一个结果
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        
        // 加入结果集
        res.add( tmpRes );
    } else {
        for( int i = t; i &amp;lt; nums.length; ++i ) {
            swap( nums, t, i);
            helperPermute( nums, t+1 );
            swap( nums, t, i);
        }
    }
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个集合的全排列, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;排列树&lt;/code&gt;问题.&lt;/p&gt;

&lt;p&gt;代码可以这样理解, 集合S的全排列由以下的结果组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S[1]+全排列( S[2…n] )&lt;/li&gt;
  &lt;li&gt;S[2]+全排列( S[1, 3…n] )&lt;/li&gt;
  &lt;li&gt;S[3]+全排列( S[2, 1, 4…n] )&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;S[n]+全排列( S[1…n-1] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是把S的中每一个元素都提取到第一位, 剩下的元素做全排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 为什么要swap2次? 因为我们要保证在处理完一次结果之后, 要恢复数组的原始状态, 这样下一次处理的时候才能正确把下一个元素交换到第一个位置来.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的全排列&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个处理过程是迭代形式的, 而且迭代过程有严格的状态要求, 那么就十分需要注意子处理过程所带来的影响.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;permutations-ii&quot;&gt;Permutations II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

  &lt;p&gt;[1,1,2], [1,2,1], and [2,1,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique( int[] nums ) {
    Arrays.sort( nums );
    helperPermuteUnique( nums, 0, nums.length-1 );
    return res;
}
private static void helperPermuteUnique( int[] nums, int i, int j ) {
    if( i == j ) {
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        res.add( tmpRes );
    } 
    for( int k = i; k &amp;lt;= j; ++k ) {
        if( findSame(nums, i, k) ) continue;
        swap( nums, i, k );
        helperPermuteUnique( nums, i+1, j );
        swap( nums, i, k );
    }
}

private static boolean findSame( int[] nums, int i, int j ) {
    for( int k = i; k &amp;lt; j; ++k )
        if( nums[j] == nums[k] ) return true;
    return false;
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 对于有重复元素集合的全排列, 可以用上面无重复元素的全排列来解决, 区别就是我们在这个基础上还要排除一些重复的全排列, 那么我们需要思考的问题是: 按照无重复元素的全排列处理过程, 如何消除重复元素带来的影响? 我们知道全排列的一次处理过程就是把每一个元素都搬到第一个位置, 然后做剩余元素的全排列, 所以我们只需要判断当前元素跟前面的元素有没有重复, 有重复的话就是已经处理过的, 直接跳过.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型去思考问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-permutations(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-permutations(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Next Permutation</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically &amp;gt; next greater permutation of numbers.&lt;/p&gt;

  &lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible &amp;gt; order (ie, sorted in ascending order).&lt;/p&gt;

  &lt;p&gt;The replacement must be in-place, do not allocate extra memory.&lt;/p&gt;

  &lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding &amp;gt; outputs are in the right-hand column.&lt;/p&gt;

  &lt;p&gt;1,2,3 → 1,3,2&lt;/p&gt;

  &lt;p&gt;3,2,1 → 1,2,3&lt;/p&gt;

  &lt;p&gt;1,1,5 → 1,5,1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void nextPermutation( int[] nums ) {

    // 从后往前找到第一个递增对 [i, i+1]
    int i = nums.length-2;
    for( ; i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i+1]; --i );

    // 已经不存在递增对, 所有排列已经列举完了, 这里重新开始
    if( i &amp;lt; 0 ) {
        reverse( nums, 0, nums.length-1 );
        return;
    }

    // 从后往前找到第一个 [j] &amp;gt; [i]
    int j = nums.length-1;
    for( ; j &amp;gt; i &amp;amp;&amp;amp; nums[j] &amp;lt;= nums[i]; --j );

    // 构造下一个全排列
    swap( nums, i, j );
    i = i + 1;
    j = nums.length-1;
    reverse( nums, i, j );
}
private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
private static void reverse( int[] nums, int i, int j ) {
    while( i &amp;lt; j ) {
        swap( nums, i++, j-- );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个排列的下一个排列, 从数值上看, 就是找到下一个值, 使得下一个值&lt;code class=&quot;highlighter-rouge&quot;&gt;比当前值大&lt;/code&gt;并且要&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;. 所以我们可以从数值的低位部分入手, 因为改变低位对数值大小的影响最小, 也就满足了&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;这个条件. 现在考虑一个例子:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, … , A&lt;sub&gt;K&lt;/sub&gt;, A&lt;sub&gt;K+1&lt;/sub&gt;, …, A&lt;sub&gt;N&lt;/sub&gt;]&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;K+1&lt;/sub&gt; &amp;gt; … &amp;gt; A&lt;sub&gt;N&lt;/sub&gt; ( 1 &amp;lt; K &amp;lt; N, 也就是[K+1…N]递减 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于[K+1…N]这部分是递减的, 那么在这部分做修改是不可能构造出一个比当前值还大的值, 所以就要第[K]位加进来, 也就是对[K…N]这部分做修改, 那么该如何改呢?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在[K+1…N]中找一个刚好比[K]大的值, 与[K]交换, 才能构造出一个比当前值大的值, 所以就可以在[K+1…N]中由后往前找合适的值([K+1…N]是递减的, 所以由后往前找)&lt;/li&gt;
  &lt;li&gt;找到合适的值之后与[K]交换, 交换之后[K+1…N]还是递减的&lt;/li&gt;
  &lt;li&gt;修改[K+1…N]这部分变为最小值, 因为[K+1…N]是递减的, 翻转以下就可以了&lt;/li&gt;
  &lt;li&gt;得到下一个全排列的值&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 求下一个排列的问题可以转化为数值的问题, 然后又要想到数值的变化影响因素中, 低位的影响是最小的, 所以思考点要转移到如何修改低位部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;专注问题的思考点, 并且不断转换思考点, 直到问题清晰可解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-next-permutation/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-next-permutation/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Subsets(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets&quot; id=&quot;markdown-toc-subsets&quot;&gt;Subsets&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets-ii&quot; id=&quot;markdown-toc-subsets-ii&quot;&gt;Subsets II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subsets&quot;&gt;Subsets&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,3], a solution is:
    [
      [3],
      [1],
      [2],
      [1,2,3],
      [1,3],
      [2,3],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsRecursion( int[] nums ) {
      Arrays.sort( nums );
      helperRecursion( nums, 0, new ArrayList&amp;lt;Integer&amp;gt;() );
      return res;
  }
  private static void helperRecursion( int[] nums, int t, List&amp;lt;Integer&amp;gt; tmpRes ) {
      // 获得一个子集
      if( t == nums.length ) {
          res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
          return;
      }
      // 不选择当前深度的节点
      helperRecursion( nums, t+1, tmpRes );

      // 选择当前深度的节点
      tmpRes.add( nums[t] );
      helperRecursion( nums, t+1, tmpRes );
      tmpRes.remove( tmpRes.size()-1 );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 求一个集合的所有子集, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;子集树&lt;/code&gt;问题, 而且这棵树是一棵完全二叉树, 利用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的递归写法可以很容易的写出代码.&lt;/p&gt;

    &lt;p&gt;处理过程: 利用一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;表示当前树的深度, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;深度的时候, 有两种选择, 一种是不选择当前深度的节点并且进入下一层, 另一种是选择当前深度的节点并且进入下一层. 其终止条件就是到达叶子节点.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetIteration( int[] nums ) {
      Arrays.sort( nums );
      List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        
      // 初始状态: 结果集中包含了子集: 空集
      res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
        
      // 构造过程: 动态生成每一个子集并且加入结果集
      for( int i = 0; i &amp;lt; nums.length; ++i ) {
          int subsetCount = res.size();
          for( int j = 0; j &amp;lt; subsetCount; ++j ) {
              List&amp;lt;Integer&amp;gt; newSubset = new ArrayList&amp;lt;&amp;gt;( res.get(j) );
              newSubset.add( nums[i] );
              res.add( newSubset );
          }
      }
        
      // 结束状态: 返回结果集
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 在思考问题解之前, 可以先思考另外一个问题: 对结果集产生影响的基本因素是什么? 基本因素就是数组中的元素. 再思考一个问题: 基本因素是如何影响结果集的? 当原本数组加入一个新的元素的时候, 由于元素在子集中可选可不选, 不选的话不会对原本的结果集产生影响, 选择的话原本的结果集会多添加一些新子集, 而且这些新子集=旧子集+新元素&lt;/p&gt;

    &lt;p&gt;处理过程: 首先, 对于任何的数组, 其结果集中一定有一个空集; 之后对每一个元素, 产生一些新子集: 新子集=旧子集+新元素, 并且把新子集加入结果集中; 最后返回结果集.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度O(2^n), 空间复杂度O(1): 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于有处理模型的问题, 我们很容易想到解决方案; 但是有时候我们并不知道处理模型是什么, 我们应该从小方面入手, 思考问题的基本因素, 从基本因素展开分析, 从而构造出一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;subsets-ii&quot;&gt;Subsets II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,2], a solution is:
    [
      [2],
      [1],
      [1,2,2],
      [2,2],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsIteration( int[] nums ) {
    Arrays.sort( nums );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
    // 初始状态: 结果集中包含了子集: 空集
    res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
    
    // 构造过程: 对每一个元素构造出新子集并加入结果集
    for( int i = 0; i &amp;lt; nums.length; ) {
        // 统计重复个数
        int repeatNum = 0;
        while( i+repeatNum &amp;lt; nums.length &amp;amp;&amp;amp;
                nums[i] == nums[repeatNum+i] ) ++repeatNum;
        // 构造子集
        int subsetCount = res.size();
        for( int j = 0; j &amp;lt; subsetCount; ++j ) {
            List&amp;lt;Integer&amp;gt; subset = new ArrayList&amp;lt;Integer&amp;gt;( res.get(j) );
            for( int k = 0; k &amp;lt; repeatNum; ++k ) {
                subset.add( nums[i] );
                res.add( new ArrayList&amp;lt;Integer&amp;gt;( subset ) );
            }
        }
        i += repeatNum;
    }
    
    // 结束状态: 返回结果集
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 其基本思考过程同上面的Subsets迭代方式差不多, 不同点在于出现了重复元素, 那么还是一样, 我们思考重复元素对原始结果集的影响是什么? 思考这样一个例子[ 1, 2, 2 ], 当处理完元素[1]的时候, 我们得到的结果集是{ {}, {1} }, 接下来对于重复元素[2], 我们可以构造出来的新子集=旧子集+(1或2)个[2], 也就是说, 对于重复元素, 我们可以选择1-n个重复元素加入旧子集形成新子集, 对于重复元素的解决方案就出来了, 最后可以得到上面的代码&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;还是一样, 对于一个新的问题, 我们应该从基本的角度去思考, 从而展开到一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/29/leetcode-subsets(II)/</link>
        <guid isPermaLink="true">/2016/03/29/leetcode-subsets(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>find指令学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#find&quot; id=&quot;markdown-toc-find&quot;&gt;find指令的用途&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#find-1&quot; id=&quot;markdown-toc-find-1&quot;&gt;find指令常用参数说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#find-2&quot; id=&quot;markdown-toc-find-2&quot;&gt;find指令常用例子&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;查找前5个最大的文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;查找某一段时间修改过的文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;在多个目录中查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;排除指定目录查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;按照文件类型查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;重复文件查找&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find&quot;&gt;find指令的用途&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在目录层次中查找满足特定要求的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;find-1&quot;&gt;find指令常用参数说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-type c: 按照文件类型c查找, 文件类型c说明如下:
    &lt;ul&gt;
      &lt;li&gt;b: 块设备文件&lt;/li&gt;
      &lt;li&gt;c: 字符设备文件&lt;/li&gt;
      &lt;li&gt;d: 目录&lt;/li&gt;
      &lt;li&gt;p: 管道文件&lt;/li&gt;
      &lt;li&gt;f: 普通文件&lt;/li&gt;
      &lt;li&gt;l: 符号链接文件&lt;/li&gt;
      &lt;li&gt;s: 套接字文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-name fname: 按照fname(不加目录前缀)查找文件&lt;/li&gt;
  &lt;li&gt;-exec command: 对查找到的文件进行指令处理, 注意结尾以’;’结束&lt;/li&gt;
  &lt;li&gt;-mmin n: 查找n分钟之前修改过的文件&lt;/li&gt;
  &lt;li&gt;-mtime n: 查找n天之前修改过的文件&lt;/li&gt;
  &lt;li&gt;-xdev: 只查找当前的文件系统&lt;/li&gt;
  &lt;li&gt;-printf: 如果find指令返回值为true, 指定格式输出结果&lt;/li&gt;
  &lt;li&gt;-prune: 排除指定的搜索范围&lt;/li&gt;
  &lt;li&gt;-o: 或者&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;find-2&quot;&gt;find指令常用例子&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;查找前5个最大的文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -type f -exec du {} \; | sort -n | tail -n 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-exec du表示对每一个找到的文件都计算文件大小&lt;/p&gt;

  &lt;p&gt;sort -n表示对所有文件按大小升序排序&lt;/p&gt;

  &lt;p&gt;tail -n 5表示取最后5个文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;查找某一段时间修改过的文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -mmin +60 -mmin -120 -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-mmin +60: 表示前60分钟之前&lt;/p&gt;

  &lt;p&gt;-mmin -120: 表示前120分钟之后&lt;/p&gt;

  &lt;p&gt;所以该指令就是查找2个小时之前的1小时内修改过的文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;在多个目录中查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find /etc /var /mnt /media -xdev -mmin -5 -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令在/etc, /var, /mnt, /media这些目录下查找&lt;/p&gt;

  &lt;p&gt;-xdev表示只对该文件系统查找&lt;/p&gt;

  &lt;p&gt;-mmin -5 表示5分钟之内修改过的文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;排除指定目录查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / \( -name proc -o -name sys \) -prune -o -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示对根目录查找, 但是排除 /proc 和 /sys这两个目录&lt;/p&gt;

  &lt;p&gt;-prune -o表示对满足括号中条件的目录排除在外&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;按照文件类型查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -name &quot;*.png&quot; -o -name &quot;*.jpg&quot; -o -name &quot;*.gif&quot; -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示在当前目录中查找格式为png, jpg, gif的文件&lt;/p&gt;

  &lt;p&gt;-o 表示或者&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-5&quot;&gt;重复文件查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type f -exec md5sum &#39;{}&#39; &#39;;&#39; | sort | uniq --all-repeated=separate -w 24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示对当前目录下的文件计算MD5并通过前24位进行比较&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/28/linux-command-find/</link>
        <guid isPermaLink="true">/2016/03/28/linux-command-find/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>IP原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ip&quot; id=&quot;markdown-toc-ip&quot;&gt;IP地址分类&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-1&quot; id=&quot;markdown-toc-ip-1&quot;&gt;IP地址编址历史&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-2&quot; id=&quot;markdown-toc-ip-2&quot;&gt;IP地址分类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-3&quot; id=&quot;markdown-toc-ip-3&quot;&gt;IP常用地址&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-4&quot; id=&quot;markdown-toc-ip-4&quot;&gt;特殊IP地址&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-5&quot; id=&quot;markdown-toc-ip-5&quot;&gt;IP地址与硬件地址&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-6&quot; id=&quot;markdown-toc-ip-6&quot;&gt;IP地址与硬件地址的原理区别&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#arp&quot; id=&quot;markdown-toc-arp&quot;&gt;ARP协议&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-7&quot; id=&quot;markdown-toc-ip-7&quot;&gt;IP数据报格式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-8&quot; id=&quot;markdown-toc-ip-8&quot;&gt;IP首部格式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;报文段切割&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-9&quot; id=&quot;markdown-toc-ip-9&quot;&gt;IP层转发分组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip&quot;&gt;IP地址分类&lt;/h3&gt;

&lt;p&gt;IP地址唯一标识网络中某一个设备, 其定义如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP ::= { 网络号 : 主机号 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ip-1&quot;&gt;IP地址编址历史&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;分类编址: IP地址可以划分为ABCDE五类, 可以参考下图&lt;/li&gt;
  &lt;li&gt;划分子网: 在分类编址的基础上定义了子网的概念和划分原理&lt;/li&gt;
  &lt;li&gt;无分类编址: 抛弃分类编址的方式, 重新定义编址方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ip-2&quot;&gt;IP地址分类&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-classification.jpg&quot; alt=&quot;IP分类编址&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ip-3&quot;&gt;IP常用地址&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-use-usually-classification.gif&quot; alt=&quot;IP常用地址&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;A类地址中减去2表示排除了网络号全0(表示&lt;code class=&quot;highlighter-rouge&quot;&gt;本网络&lt;/code&gt;)和网络号127(表示&lt;code class=&quot;highlighter-rouge&quot;&gt;环回地址&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;B类地址中减去1表示排除了128.0(保留)网络&lt;/li&gt;
    &lt;li&gt;C类地址中减去1表示排除了192.0.0(保留)网络&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ip-4&quot;&gt;特殊IP地址&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-use-rarely.jpg&quot; alt=&quot;特殊IP地址&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-5&quot;&gt;IP地址与硬件地址&lt;/h3&gt;

&lt;p&gt;IP地址唯一表示网络中的某一个设备, 硬件地址也是唯一表示某一个设备, 那么为什么需要两种地址呢?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是因为全世界有着各种各样的网络, 不同的网络使用不同的硬件地址, 为了使得这些异构网络之间能够通信, 就需要一个统一的规则来表示每个设备, 也就是IP地址了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ip-6&quot;&gt;IP地址与硬件地址的原理区别&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-ipAddress-and-macAddress.jpg&quot; alt=&quot;IP地址与硬件地址的原理区别&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;arp&quot;&gt;ARP协议&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ARP协议&lt;/code&gt;是用来找出IP地址对应的硬件地址, 还有一个协议是&lt;code class=&quot;highlighter-rouge&quot;&gt;RARP协议&lt;/code&gt;, 是用来找出硬件地址对应的IP地址, 这两个协议都是处于网络层中&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ARP协议&lt;/code&gt;的工作原理如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-arp.jpg&quot; alt=&quot;ARP协议的工作原理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ARP工作原理解释如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主机A在局域网中广播ARP请求分组&lt;/li&gt;
  &lt;li&gt;所有主机都受到ARP请求分组, 但是只有主机B响应分组&lt;/li&gt;
  &lt;li&gt;主机A收到主机B的响应分组, 在ARP高速缓存中记录主机B&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;主机A发送出ARP请求分组, 主机B会在ARP高速缓存中记录主机A, 这样可以避免主机B要找主机A的时候也要发出一个ARP请求分组, 减少了网络开销&lt;/li&gt;
    &lt;li&gt;ARP高速缓存中的记录是有生存时间的, 过了生存时间的记录就会自动删除, 这是基于网络中的硬件地址是动态变更这种情况考虑的, 例如主机B换了一个网络适配器, 其先前的地址也就无效了&lt;/li&gt;
    &lt;li&gt;ARP协议是解决同一个局域网内的主机中IP地址与硬件地址的映射问题&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-7&quot;&gt;IP数据报格式&lt;/h3&gt;

&lt;h4 id=&quot;ip-8&quot;&gt;IP首部格式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-header.jpg&quot; alt=&quot;IP数据报格式&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;版本: IP协议版本(IPv4, IPv6等)&lt;/li&gt;
  &lt;li&gt;首部长度: IP首部的字节长度, 范围为20~60&lt;/li&gt;
  &lt;li&gt;区分服务: 更多服务&lt;/li&gt;
  &lt;li&gt;总长度: IP数据报的长度, 范围为20~65535字节, 一般以太网使用的MTU(Maximum Transfer Unit)为1500, MTU表示IP数据报中数据部分的最大长度&lt;/li&gt;
  &lt;li&gt;标识: 报文段发生分片的时候使用, 接收端通过标识可以合并同一个标识的IP数据报&lt;/li&gt;
  &lt;li&gt;标志: 目前使用DF(Don’t Fragment)和MF(More Fragment)&lt;/li&gt;
  &lt;li&gt;片偏移: IP数据报合并时, 用来确认每一个IP数据报在原始报文段中的位置, 8个字节为单位&lt;/li&gt;
  &lt;li&gt;生存时间: IP数据报的生存时间, 目前一般表示跳数&lt;/li&gt;
  &lt;li&gt;协议: 表示IP数据报使用的协议, 例如: TCP, UDP, OSPF&lt;/li&gt;
  &lt;li&gt;首部检验和: 检验IP首部, 每一次路由转发后, 都会检验首部的正确性&lt;/li&gt;
  &lt;li&gt;源地址: 发送方IP地址&lt;/li&gt;
  &lt;li&gt;目的地址: 接收方IP地址&lt;/li&gt;
  &lt;li&gt;可选字段(长度可变)&lt;/li&gt;
  &lt;li&gt;填充: IP首部填充0, 知道满足以4个字节为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;报文段切割&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-data-split.png&quot; alt=&quot;IP数据报分片举例&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;解释如下:
原始题目中规定IP数据报的&lt;code class=&quot;highlighter-rouge&quot;&gt;MTU&lt;/code&gt;为1400, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;是以8个字节为单位, 我们发现8能够整除1400, 所以我们可以直接以1400个字节为切割单位, 分别切割出1400/1400/1000这样的3个数据, 然后分别计算&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;, 得到0/175/350, 这样把这些数据写到各自的首部中, 另外还需要给这3个数据一个共同的&lt;code class=&quot;highlighter-rouge&quot;&gt;标识&lt;/code&gt;(例如:12345).&lt;/p&gt;

  &lt;p&gt;这样切割之后, 接收端就可以根据&lt;code class=&quot;highlighter-rouge&quot;&gt;标识&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;来组合IP数据报, 得到原始的报文段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-9&quot;&gt;IP层转发分组&lt;/h3&gt;

&lt;p&gt;转发分组涉及两个概念: &lt;code class=&quot;highlighter-rouge&quot;&gt;路由&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;路由 ::= ( 目的网络地址, 下一跳地址 )
路由表 ::= 包含路由信息的表格
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个IP数据报的转发都需要查询&lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-transfer-algorithm.jpg&quot; alt=&quot;IP层转发分组&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分组转发算法流程如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;从IP数据报首部中提取目的IP地址D, 并计算得到网络地址N&lt;/li&gt;
    &lt;li&gt;如果N就是与路由器直接相连的网络, 那么直接交付到目的主机, 否则执行(3)&lt;/li&gt;
    &lt;li&gt;如果路由表中有目的地址D的特定主机路由, 那么交付特定路由器, 否则执行(4)&lt;/li&gt;
    &lt;li&gt;如果路由表中有目的网络N的转发地址, 那么交付对应的路由器, 否则执行(5)&lt;/li&gt;
    &lt;li&gt;如果路由表中有默认路由, 那么交付默认路由器, 否则执行(6)&lt;/li&gt;
    &lt;li&gt;报告转发分组出错&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/27/computer-network-ip/</link>
        <guid isPermaLink="true">/2016/03/27/computer-network-ip/</guid>
        
        
        <category>计算机网络</category>
        
      </item>
    
      <item>
        <title>回溯法原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;回溯法定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;回溯法原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;回溯法算法框架&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;递归回溯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;迭代回溯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;子集树&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;排列树&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;回溯法定义&lt;/h3&gt;

&lt;p&gt;回溯法是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;搜索算法&lt;/code&gt;, 可以系统地搜索一个问题的&lt;code class=&quot;highlighter-rouge&quot;&gt;所有解&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;任一解&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回溯法原理&lt;/h3&gt;

&lt;p&gt;回溯法的搜索原理是&lt;code class=&quot;highlighter-rouge&quot;&gt;深度优先搜索策略&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原理: &lt;strong&gt;首先定义问题的解空间&lt;/strong&gt;, 举个&lt;code class=&quot;highlighter-rouge&quot;&gt;0-1背包&lt;/code&gt;的例子, 假设只有两个东西, 那么解空间可以这样表示{(00),(01),(10),(11)}; &lt;strong&gt;其次组织解空间, 一般组织为树或者图&lt;/strong&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;0-1背包&lt;/code&gt;的解空间就变成了一棵完全二叉树; &lt;strong&gt;最后是开始搜索&lt;/strong&gt;, 过程是这样的: 从根节点出发, 以深搜方式搜索整个解空间. 根节点首先成为&lt;code class=&quot;highlighter-rouge&quot;&gt;活节点&lt;/code&gt;, 并且纵向移至下一个新节点, 新节点就成为了&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;无法再纵向移动, 那么就成为了&lt;code class=&quot;highlighter-rouge&quot;&gt;死节点&lt;/code&gt;, 此时就应该回溯到最近一个&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;处, 继续用以上的方式进入下一个扩展.&lt;/p&gt;

&lt;p&gt;回溯法以这种方式在解空间中搜索, 直到找到所要求的解活解空间中已经没有&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;为止&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法的步骤如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;针对所给问题, 定义问题的解空间&lt;/li&gt;
    &lt;li&gt;确定易于搜索的解空间结构&lt;/li&gt;
    &lt;li&gt;以深搜方式搜索解空间, 并在搜索过程中使用剪枝函数避免无效搜索&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;回溯法算法框架&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;递归回溯&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            x[ t ] = h( i );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;t 表示递归深度&lt;/li&gt;
    &lt;li&gt;n 表示解空间树的总深度&lt;/li&gt;
    &lt;li&gt;x 表示可行解&lt;/li&gt;
    &lt;li&gt;f(n,t) 表示当前&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;未搜索过的子树起始编号&lt;/li&gt;
    &lt;li&gt;g(n,t) 表示当前&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;未搜索过的子树终止编号&lt;/li&gt;
    &lt;li&gt;constraint(t) 表示约束函数, 用于确认x[1…t]是否满足约束条件, 不满足条件可以剪枝&lt;/li&gt;
    &lt;li&gt;bound(t) 表示限界函数, 用于确认x[1…t]是否使目标函数越界, 使目标函数越界可以剪枝&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;迭代回溯&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void iterativeBackTrack() {
    int t = 1;
    while( t &amp;gt; 0 ) {
        if( f( n, t ) &amp;lt;= g( n, t ) ) {
            for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
                x[ t ] = h( i );
                if( constraint( t ) &amp;amp;&amp;amp; bound( t ) ) {
                    if( solution( t ) )	//表示有可行解
                        Output( x );
                    else
                        ++t;
                }
            }
        } else {
            --t;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;子集树&lt;/h4&gt;

&lt;p&gt;子集树定义:当所给的问题是从n个元素的集合中找出满足某种性质的子集时, 相应的解空间树称为子集树, 其解空间大小为O(2^n)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            x[ t ] = h( i );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;排列树&lt;/h4&gt;

&lt;p&gt;排列树定义:当所给的问题是从n个元素的集合中找出满足某种性质的排列时, 相应的解空间树称为排列树, 其解空间大小为O(n!)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            // swap表示交换元素
            swap( x[t], x[i] );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
            swap( x[t], x[i] );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/27/algorithm-backtracking/</link>
        <guid isPermaLink="true">/2016/03/27/algorithm-backtracking/</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>TCP原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp&quot; id=&quot;markdown-toc-tcp&quot;&gt;TCP概述&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tcp-1&quot; id=&quot;markdown-toc-tcp-1&quot;&gt;TCP特点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tcp-2&quot; id=&quot;markdown-toc-tcp-2&quot;&gt;TCP连接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-3&quot; id=&quot;markdown-toc-tcp-3&quot;&gt;TCP报文段&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-4&quot; id=&quot;markdown-toc-tcp-4&quot;&gt;TCP可靠传输&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;滑动窗口&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;超时重传&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;选择确认&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-5&quot; id=&quot;markdown-toc-tcp-5&quot;&gt;TCP流量控制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-6&quot; id=&quot;markdown-toc-tcp-6&quot;&gt;TCP拥塞控制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;拥塞控制原理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;拥塞控制方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcp-7&quot; id=&quot;markdown-toc-tcp-7&quot;&gt;TCP连接管理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;建立连接&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;释放连接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcp&quot;&gt;TCP概述&lt;/h3&gt;

&lt;h4 id=&quot;tcp-1&quot;&gt;TCP特点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;面向连接: 在连接的基础上双方才可以通信&lt;/li&gt;
  &lt;li&gt;端到端: 通信只有两个端点&lt;/li&gt;
  &lt;li&gt;可靠交付: 传输什么样的数据, 就接受什么样的数据&lt;/li&gt;
  &lt;li&gt;全双工通信: 通信是双向的, 而且不会相互干扰&lt;/li&gt;
  &lt;li&gt;面向字节流: 数据以字节传输, 表明TCP不知道数据的含义&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tcp-2&quot;&gt;TCP连接&lt;/h4&gt;

&lt;p&gt;什么是TCP连接? TCP连接就是一个抽象表示, 指出了通信双方的身份.&lt;/p&gt;

&lt;p&gt;通信中的一方我们用套接字(socket)表示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;套接字socket = ( IP地址: 端口号 )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而且我们知道TCP连接是&lt;code class=&quot;highlighter-rouge&quot;&gt;端到端&lt;/code&gt;的, 所以TCP连接可以这样表示:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP连接 ::= { socket1, socket2 } = { (IP1: port1), (IP2: port2) }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-3&quot;&gt;TCP报文段&lt;/h3&gt;

&lt;p&gt;TCP报文段的组成很简单, 只有首部和数据, 表示如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP报文段 ::= TCP首部 + 数据部分
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;TCP首部信息如下图所示(注:数字表示位数):
&lt;img src=&quot;\assets\computer-network\tcp-header.png&quot; alt=&quot;TCP首部信息&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首部信息中各字段解释如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;源端口: 发送方port, 可知端口范围为0~65535&lt;/li&gt;
  &lt;li&gt;目的端口: 接收方port, 可知端口范围为0~65535&lt;/li&gt;
  &lt;li&gt;序号: 报文段的编号, 可知序号范围0~2^32^-1, 由于TCP是面向字节流的,所以一个序号表示一个字节&lt;/li&gt;
  &lt;li&gt;确认号: 告知对方自己期望的下一个报文段编号&lt;/li&gt;
  &lt;li&gt;数据偏移: TCP首部长度, 表示到达数据部分的偏移量, 范围为0~15, 所以首部长度最多为60字节&lt;/li&gt;
  &lt;li&gt;保留: 未定义&lt;/li&gt;
  &lt;li&gt;URG: 紧急位, 用于设置紧急指针&lt;/li&gt;
  &lt;li&gt;ACK: 确认位, 用于设置确认号&lt;/li&gt;
  &lt;li&gt;PSH: 推送位, 告知TCP数据发送&lt;/li&gt;
  &lt;li&gt;RST: 重置位, 告知对方TCP出现错误,需要重新连接&lt;/li&gt;
  &lt;li&gt;SYN: 同步位, 建立连接的标志&lt;/li&gt;
  &lt;li&gt;FIN: 结束位, 释放连接的标志&lt;/li&gt;
  &lt;li&gt;窗口: 告知对方自己的接受窗口&lt;/li&gt;
  &lt;li&gt;检验和: 检验TCP报文段的有效性, 包括TCP首部和数据部分&lt;/li&gt;
  &lt;li&gt;紧急指针: URG置1有效, 定位紧急数据&lt;/li&gt;
  &lt;li&gt;选项(长度可变): 用于扩展TCP首部信息&lt;/li&gt;
  &lt;li&gt;填充: 填充TCP首部格式使得满足以4字节为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP报文段的规则中定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;MSS&lt;/code&gt;(Maximum Segment Size:最大报文段长度), 表示TCP报文段中数据部分的最大长度, 默认值是536, 所以因特网中的所有主机都应能够接受536+20=556字节的最大报文段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-4&quot;&gt;TCP可靠传输&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;可靠传输&lt;/strong&gt;有三个方面的含义:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无差错: 数据传输之前之后是一样的&lt;/li&gt;
  &lt;li&gt;不丢失: 发送方发送的数据, 接收方一定可以接收到&lt;/li&gt;
  &lt;li&gt;不重复: 发送方发送的数据, 接收方不会重复接受&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;滑动窗口&lt;/h4&gt;

&lt;p&gt;滑动窗口是基于字节流的, 所以滑动的单位为1字节, 其结构如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-sliding-window.png&quot; alt=&quot;滑动窗口结构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说明如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Category #1: 已发送, 已确认&lt;/li&gt;
  &lt;li&gt;Category #2: 已发送, 未确认&lt;/li&gt;
  &lt;li&gt;Category #3: 未发送, 可发送&lt;/li&gt;
  &lt;li&gt;Category #4: 未发送, 不可发送&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意的细节问题:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;发送窗口可能要比接受窗口小, 因为发送方要考虑网络拥塞问题&lt;/li&gt;
    &lt;li&gt;对于不按序到达的数据如何处理, TCP标准没有说明. 但是考虑网络资源的珍贵性, 一般情况下接收方都会接受下来暂时保存着&lt;/li&gt;
    &lt;li&gt;接收方必须要有累计确认的功能, 因为这样可以很好的减小开销&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;超时重传&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;超时重传&lt;/strong&gt;是为了保证可靠传输, 其实现涉及两个东西: &lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;(Round-Time Trip)和&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;(Retransmission Time-Out).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;: 报文段往返时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;: 超时重传时间, 略大于&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个报文段发送出去, 如果过了&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;时间还没有接收到确认, 那么就需要重传报文段&lt;/p&gt;

&lt;p&gt;我们知道网络情况是动态的, 有时候网络良好, 有时候网络拥塞, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;就应该也是动态变化的,&lt;code class=&quot;highlighter-rouge&quot;&gt;RTO&lt;/code&gt;自然而然也就跟着&lt;code class=&quot;highlighter-rouge&quot;&gt;RTT&lt;/code&gt;动态变化. 这个动态变化就需要设计一个算法来计算, 我们这里就简单讲一下3个算法.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;自适应算法:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RTTs = (1-a)*(旧RTTs) + a*(新RTT样本)
  RTO = RTTs + 4*RTTD (注:RTTD表示RTT偏差加权平均值)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Karn算法: 在自适应算法基础上, 提出只要报文段重传, 那么就不采用其样本RTT&lt;/li&gt;
  &lt;li&gt;Karn修正算法: 在Karn算法基础上, 剔除只要报文段重传, 那么RTO就增大一点&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;选择确认&lt;/h4&gt;

&lt;p&gt;SAK(Selective ACK)选择确认是指在发生数据未按序到达的时候, 接收方告诉发送方自己接收了哪些数据, 从而发送发可以决定重发丢失的数据, 而不是全部重新重发, 使得网络资源得到更好的利用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SAK的实现原理是借助TCP首部信息中的&lt;code class=&quot;highlighter-rouge&quot;&gt;选项(可选长度)&lt;/code&gt;这一部分. 我们知道一个连续的字节段可以由头序号和尾序号表示, 一个序号需要4个字节, 所以一个字节段需要8个字节表示, 那么我们是不是一次告诉发送方5个字节段呢?(首部最长60字节,20字节是固定的,所以有&lt;code class=&quot;highlighter-rouge&quot;&gt;40字节/8字节=5&lt;/code&gt;). 然而并没有, 因为还需要2个字节, 分别表明使用SAK选项和选项长度, 所以只有40-2=38个字节可用, 所以一次最多告诉发送方4个字节段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-5&quot;&gt;TCP流量控制&lt;/h3&gt;

&lt;p&gt;所谓流量控制, 就是接收方让发送方不要发送太多的数据, 好让接收方来得及接受, 过程如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-flow-control.jpg&quot; alt=&quot;TCP流量控制&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出, 接收方一共进行了3次流量控制&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 现在考虑一种情况, 在上图中, 接下来B处理完了缓冲区的数据, 那么B就会发送一个rwnd=400的报文段, 然而报文段却在中途丢失了, 那么A就一直等B的通知, 而B也一直等A发数据, 因为B认为自己已经通知A可以发送了, 这样就形成了一个死锁.
所以TCP为每一个连接都设置了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;持续计时器&lt;/code&gt;, 每当接收方得知发送方的发送窗口值为0的时候, 启动&lt;code class=&quot;highlighter-rouge&quot;&gt;持续计时器&lt;/code&gt;, 时间一到接收方就发送一个&lt;code class=&quot;highlighter-rouge&quot;&gt;探测报文段&lt;/code&gt;, 一直持续这个过程直到发送方的发送窗口不为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tcp-6&quot;&gt;TCP拥塞控制&lt;/h3&gt;

&lt;p&gt;所谓拥塞控制, 就是防止过多的数据注入到网络中, 使得网络中的路由器或链路不致过载&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 拥塞控制不同于流量控制, 拥塞控制是基于整个网络考虑, 而流量控制是基于通信双方考虑&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;拥塞控制原理&lt;/h4&gt;

&lt;p&gt;拥塞控制从大方面考虑可以分为两种: &lt;code class=&quot;highlighter-rouge&quot;&gt;开环控制&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;开环控制&lt;/code&gt;是指在网络设计的时候把相关拥塞因素考虑进来, 一旦网络运行起来就不变更了; &lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;则是动态地考虑拥塞情况并做出控制, 我们这里讲一下&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;的原理&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;是基于反馈环路的概念.属于&lt;code class=&quot;highlighter-rouge&quot;&gt;闭环控制&lt;/code&gt;有以下几步&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检测网络系统得知拥塞发生的时间地点&lt;/li&gt;
  &lt;li&gt;把拥塞信息发送到可以采取行动的地方&lt;/li&gt;
  &lt;li&gt;调整网络系统的运行以解决拥塞问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-4&quot;&gt;拥塞控制方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;慢开始(slow-start): 从发送数据开始, 拥塞窗口逐渐增大&lt;/li&gt;
  &lt;li&gt;拥塞避免(congestion avoidance): 从感知到拥塞开始, 拥塞窗口缓慢增大&lt;/li&gt;
  &lt;li&gt;快重传(fast retransmit): 从丢失报文段开始, 不断重复确认丢失报文段, 使得尽快重传报文段&lt;/li&gt;
  &lt;li&gt;快恢复(fast recovery): 从发现快重传开始, 缩小一半拥塞窗口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;慢开始&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;拥塞避免&lt;/code&gt;一起使用, &lt;code class=&quot;highlighter-rouge&quot;&gt;快重传&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;快恢复&lt;/code&gt;一起使用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;慢开始&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;拥塞避免&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-slow-start-and-congestion-avoidance.jpg&quot; alt=&quot;慢开始和拥塞避免&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;快重传&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;快恢复&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-fast-retransmit-fast-recovery.jpg&quot; alt=&quot;快重传和快恢复&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;ssthresh是指慢开始门限, 也就是慢开始算法切换掉的分割线&lt;/li&gt;
    &lt;li&gt;慢开始算法的拥塞窗口起始值是1&lt;/li&gt;
    &lt;li&gt;发送方窗口上限值 = Min [ rwnd, cwnd ]&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-7&quot;&gt;TCP连接管理&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;建立连接&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-link-create.png&quot; alt=&quot;TCP建立连接&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里为什么需要三次握手, 而不是两次握手呢?&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;主要是从服务端角度考虑, 目的是为了不浪费服务端资源&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;考虑两次握手的情景, 客户端发送了请求连接(1), 但是延迟了, 于是客户端再发送一次请求连接(2), 并且完成了通信和释放了连接(2), 之后服务端收到了连接(1)并建立连接, 但是客户端已经不需要连接(1)了, 所以连接(1)会造成服务端网络资源的浪费&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;但是使用三次握手会引来另外一个问题: 客户端资源的浪费&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;主要是因为客户端发送第三次握手过后, 客户端就可以发送数据了, 但是连接是否建立成功还不一定, 所以就有可能造成客户端资源的浪费&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-6&quot;&gt;释放连接&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;\assets\computer-network\tcp-link-release.gif&quot; alt=&quot;TCP建立连接&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP连接建立和释放过程中, 每一步报文段分别发生丢失我们要怎么处理呢?&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;关键在于理解: 无论客户端还是服务端, 只要是状态变更的发起者, 那么就要负责重传服务&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;例如1: 在TCP连接建立过程中, 客户端从CLOSED到SYN-SENT, 状态发生变更发起者是客户端, 客户端就要负责失败重传; 服务端从LISTEN到SYN-RCVD, 状态发生变更发起者是服务器, 服务端要负责失败重传&lt;/p&gt;

  &lt;p&gt;例如2:在TCP连接释放过程中, 客户端从ESTABLISHED到FIN-WAIT1, 状态发生变更发起者是客户端, 客户端份负责重传; 服务端从CLOSE-WAIT到LAST-ACK, 状态发生变更发起者是服务端, 服务端负责重传&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 26 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/26/computer-network-tcp/</link>
        <guid isPermaLink="true">/2016/03/26/computer-network-tcp/</guid>
        
        
        <category>计算机网络</category>
        
      </item>
    
      <item>
        <title>Jekyll学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll&quot; id=&quot;markdown-toc-jekyll&quot;&gt;什么是Jekyll&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;基本用法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#build&quot; id=&quot;markdown-toc-build&quot;&gt;build(编译)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#serve&quot; id=&quot;markdown-toc-serve&quot;&gt;serve(运行)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;目录结构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;配置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;全局配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;编译选项&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;服务选项&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;默认选项&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;头信息&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;预定义全局变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;自定义变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;预定义局部变量&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;写文章&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;文章命名&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;引用图片和其他资源&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;文章目录&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;文章摘要&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-17&quot; id=&quot;markdown-toc-section-17&quot;&gt;代码片段高亮&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-18&quot; id=&quot;markdown-toc-section-18&quot;&gt;显示行数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-19&quot; id=&quot;markdown-toc-section-19&quot;&gt;写草稿&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-20&quot; id=&quot;markdown-toc-section-20&quot;&gt;草稿目录&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-21&quot; id=&quot;markdown-toc-section-21&quot;&gt;草稿生成&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-22&quot; id=&quot;markdown-toc-section-22&quot;&gt;创建页面&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-23&quot; id=&quot;markdown-toc-section-23&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-24&quot; id=&quot;markdown-toc-section-24&quot;&gt;其他页面&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-25&quot; id=&quot;markdown-toc-section-25&quot;&gt;常用变量&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-26&quot; id=&quot;markdown-toc-section-26&quot;&gt;全局变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-27&quot; id=&quot;markdown-toc-section-27&quot;&gt;全站变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-28&quot; id=&quot;markdown-toc-section-28&quot;&gt;页面变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-29&quot; id=&quot;markdown-toc-section-29&quot;&gt;分页器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-30&quot; id=&quot;markdown-toc-section-30&quot;&gt;模板&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-31&quot; id=&quot;markdown-toc-section-31&quot;&gt;过滤器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-32&quot; id=&quot;markdown-toc-section-32&quot;&gt;标签&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-33&quot; id=&quot;markdown-toc-section-33&quot;&gt;永久链接&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-34&quot; id=&quot;markdown-toc-section-34&quot;&gt;模板变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-35&quot; id=&quot;markdown-toc-section-35&quot;&gt;链接类型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-36&quot; id=&quot;markdown-toc-section-36&quot;&gt;举例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-37&quot; id=&quot;markdown-toc-section-37&quot;&gt;分页&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-38&quot; id=&quot;markdown-toc-section-38&quot;&gt;开启分页&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-39&quot; id=&quot;markdown-toc-section-39&quot;&gt;分页例子&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-40&quot; id=&quot;markdown-toc-section-40&quot;&gt;插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;什么是Jekyll&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;官方定义&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown （或者 Textile） 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;基本用法&lt;/h3&gt;

&lt;h4 id=&quot;build&quot;&gt;build(编译)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll build
# =&amp;gt; 当前文件夹中的内容将会生成到 ./site 文件夹中。

$ jekyll build --destination &amp;lt;destination&amp;gt;
# =&amp;gt; 当前文件夹中的内容将会生成到目标文件夹&amp;lt;destination&amp;gt;中。

$ jekyll build --source &amp;lt;source&amp;gt; --destination &amp;lt;destination&amp;gt;
# =&amp;gt; 指定源文件夹&amp;lt;source&amp;gt;中的内容将会生成到目标文件夹&amp;lt;destination&amp;gt;中。

$ jekyll build --watch
# =&amp;gt; 当前文件夹中的内容将会生成到 ./site 文件夹中，
#    查看改变，并且自动再生成。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;serve&quot;&gt;serve(运行)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll serve
# =&amp;gt; 一个开发服务器将会运行在 http://localhost:4000/

$ jekyll serve --detach
# =&amp;gt; 功能和`jekyll serve`命令相同，但是会脱离终端在后台运行。
#    如果你想关闭服务器，可以使用`kill -9 1234`命令，&quot;1234&quot; 是进程号（PID）。
#    如果你找不到进程号，那么就用`ps aux | grep jekyll`命令来查看，然后关闭服务器。

$ jekyll serve --watch
# =&amp;gt; 和`jekyll serve`相同，但是会查看变更并且自动再生成。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;目录结构&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_drafts&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_data&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;全局配置&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
      	&lt;td&gt;说明&lt;/td&gt;
		&lt;td&gt;配置&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;源文件地址&lt;/td&gt;
		&lt;td&gt;source: DIR&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;目标文件地址&lt;/td&gt;
		&lt;td&gt;destination: DIR&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;禁用插件&lt;/td&gt;
		&lt;td&gt;safe: bool&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;编译时排除项&lt;/td&gt;
		&lt;td&gt;exclude: [DIR, FILE, …]&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;编译时包含项&lt;/td&gt;
		&lt;td&gt;include: [DIR, FILE, …]&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;时区&lt;/td&gt;
		&lt;td&gt;timezone: TIMEZONE&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;文件编码&lt;/td&gt;
		&lt;td&gt;encoding: ENCODING&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-4&quot;&gt;编译选项&lt;/h4&gt;
&lt;table&gt;
    &lt;tr&gt;
    	&lt;td&gt;说明&lt;/td&gt;
    	&lt;td&gt;配置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;允许文件修改时自动重新生成网站。&lt;/td&gt;
    	&lt;td&gt;-w, --watch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;手动设置配置文件并替代_config.yml&lt;/td&gt;
    	&lt;td&gt;--config FILE1[,FILE2,...]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;处理草稿&lt;/td&gt;
    	&lt;td&gt;--drafts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;用将来的日期发布文章&lt;/td&gt;
    	&lt;td&gt;--future&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;相关文章生成索引&lt;/td&gt;
    	&lt;td&gt;--lsi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;限制文章的数量&lt;/td&gt;
    	&lt;td&gt;--limit_posts NUM&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-5&quot;&gt;服务选项&lt;/h4&gt;
&lt;table&gt;
    &lt;tr&gt;
    	&lt;td&gt;说明&lt;/td&gt;
    	&lt;td&gt;配置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;监听所给的端口&lt;/td&gt;
    	&lt;td&gt;--port PORT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;监听所给的主机名&lt;/td&gt;
    	&lt;td&gt;--host HOSTNAME&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;网站的根路径&lt;/td&gt;
    	&lt;td&gt;--baseurl URL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    	&lt;td&gt;从终端命令行中分离出来&lt;/td&gt;
   		&lt;td&gt;-B, --detach&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-6&quot;&gt;默认选项&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source:      .
destination: ./_site
plugins:     ./_plugins
layouts:     ./_layouts
include:     [&#39;.htaccess&#39;]	(注*:该文件定义了针对目录的权限规则)
exclude:     []
keep_files:  [&#39;.git&#39;,&#39;.svn&#39;]
gems:        []
timezone:    nil
encoding:    nil

future:      true
show_drafts: nil
limit_posts: 0
highlighter: pygments

relative_permalinks: true

permalink:     date
paginate_path: &#39;page:num&#39;
paginate:      nil

markdown:      maruku
markdown_ext:  markdown,mkd,mkdn,md
textile_ext:   textile

excerpt_separator: &quot;\n\n&quot;

safe:        false
watch:       false    # deprecated
server:      false    # deprecated
host:        0.0.0.0
port:        4000
baseurl:     /
url:         http://localhost:4000
lsi:         false

maruku:
    use_tex:    false
    use_divs:   false
    png_engine: blahtex
    png_dir:    images/latex
    png_url:    /images/latex
    fenced_code_blocks: true

rdiscount:
	extensions: []

redcarpet:
	extensions: []

kramdown:
    auto_ids: true
    footnote_nr: 1
    entity_output: as_char
    toc_levels: 1..6
    smart_quotes: lsquo,rsquo,ldquo,rdquo
    use_coderay: false

coderay:
    coderay_wrap: div
    coderay_line_numbers: inline
    coderay_line_numbers_start: 1
    coderay_tab_width: 4
    coderay_bold_every: 10
    coderay_css: style

redcloth:
hard_breaks: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-7&quot;&gt;头信息&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;结构&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# =&amp;gt;头信息写在两行三虚线之间
---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-9&quot;&gt;预定义全局变量&lt;/h4&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;变量名&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;layout&lt;/td&gt;
        &lt;td&gt;布局文件, 从_layout中选择&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;permalink&lt;/td&gt;
        &lt;td&gt;文章命名格式要求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;published&lt;/td&gt;
        &lt;td&gt;文章具体内容是否展示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;category/categories&lt;/td&gt;
        &lt;td&gt;文章分类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;tags&lt;/td&gt;
        &lt;td&gt;文章标签&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-10&quot;&gt;自定义变量&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 头信息中未被定义的变量将在此页面中定义并使用 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{{ page.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-11&quot;&gt;预定义局部变量&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 页面中已经定义好了局部变量 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{{ page.date }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-12&quot;&gt;写文章&lt;/h3&gt;

&lt;h4 id=&quot;section-13&quot;&gt;文章命名&lt;/h4&gt;

&lt;h4 id=&quot;section-14&quot;&gt;引用图片和其他资源&lt;/h4&gt;

&lt;p&gt;首先在网站目录下创建自己的资源文件夹, 例如assets\或者downloads\,
之后在页面中使用site.访问, 例子如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![有帮助的截图](/assets/screenshot.jpg)
… 你可以直接 [下载 PDF](/assets/mydoc.pdf).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-15&quot;&gt;文章目录&lt;/h4&gt;

&lt;p&gt;列举网站包含的所有文章代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    {% for post in site.posts %}
    &amp;lt;li&amp;gt;
    	&amp;lt;a href=&quot;{{ post.url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    {% endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-16&quot;&gt;文章摘要&lt;/h4&gt;

&lt;p&gt;Jekyll 会自动取每篇文章从开头到第一次出现&lt;code class=&quot;highlighter-rouge&quot;&gt;excerpt_separator&lt;/code&gt;的地方作为文章的摘要， 并将此内容保存到变量&lt;code class=&quot;highlighter-rouge&quot;&gt;post.excerpt&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    {% for post in site.posts %}
    &amp;lt;li&amp;gt;
    	&amp;lt;a href=&quot;{{ post.url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;
    	{{ post.excerpt }}
    &amp;lt;/li&amp;gt;
    {% endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-17&quot;&gt;代码片段高亮&lt;/h4&gt;

&lt;p&gt;Jekyll 自带语法高亮功能，它是由 Pygments 来实现的。在文章中插入一段高亮代码非常 容易，只需使用下面的 Liquid 标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;highlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ruby&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@widget&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Widget(params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;respond_to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|format|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;format.html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;show.html.erb&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;format.json&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;json:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@widget&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endhighlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-18&quot;&gt;显示行数&lt;/h4&gt;

&lt;p&gt;Jekyll 显示行数功能也是很简单, 代码如下所示:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;highlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ruby&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;linenos&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@widget&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Widget(params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;respond_to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|format|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;format.html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;show.html.erb&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;format.json&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;json:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@widget&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endhighlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-19&quot;&gt;写草稿&lt;/h3&gt;

&lt;h4 id=&quot;section-20&quot;&gt;草稿目录&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;|-- _drafts/
|   |-- a-draft-post.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-21&quot;&gt;草稿生成&lt;/h4&gt;

&lt;p&gt;为了预览你拥有草稿的网站，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt; 或者带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;--drafts&lt;/code&gt; 配置选项的 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;。此两种方法皆会将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Time.now&lt;/code&gt; 的值赋予草稿文章，作为其发布日期，所以你将看到草稿文章作为最新文章被生成。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-22&quot;&gt;创建页面&lt;/h3&gt;

&lt;h4 id=&quot;section-23&quot;&gt;主页&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt;放在网站根目录下即可&lt;/p&gt;

&lt;h4 id=&quot;section-24&quot;&gt;其他页面&lt;/h4&gt;

&lt;p&gt;将 HTML 文件放在哪里取决于你想让它们如何工作。有两种方式可以创建页面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;命名 HTML 文件：将命名好的为页面准备的 HTML 文件放在站点的根目录下。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes/
|-- _layouts/
|-- _posts/
|-- _site/
|-- about.html    # =&amp;gt; http://example.com/about.html
|-- index.html    # =&amp;gt; http://example.com/
└── contact.html  # =&amp;gt; http://example.com/contact.html
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命名文件夹：在站点的根目录下为每一个页面创建一个文件夹，并把 index.html 文件放在每 个文件夹里。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── _config.yml
├── _includes/
├── _layouts/
├── _posts/
├── _site/
├── about/
|   └── index.html  # =&amp;gt; http://example.com/about/
├── contact/
|   └── index.html  # =&amp;gt; http://example.com/contact/
└── index.html      # =&amp;gt; http://example.com/
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-25&quot;&gt;常用变量&lt;/h3&gt;

&lt;h4 id=&quot;section-26&quot;&gt;全局变量&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;变量&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site&lt;/td&gt;
        &lt;td&gt;来自_config.yml文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page&lt;/td&gt;
        &lt;td&gt;通过 YAML 头文件自定义的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;content&lt;/td&gt;
        &lt;td&gt; Post 或者 Page 渲染生成的内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator&lt;/td&gt;
        &lt;td&gt;paginate 配置开启后可使用,分页信息&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-27&quot;&gt;全站变量&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;变量&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.time&lt;/td&gt;
        &lt;td&gt;网站启动当前时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.pages&lt;/td&gt;
        &lt;td&gt;Pages 清单&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.posts&lt;/td&gt;
        &lt;td&gt; Posts 清单&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.related_posts&lt;/td&gt;
        &lt;td&gt;相关的 Post&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.categories.CATEGORY&lt;/td&gt;
        &lt;td&gt;CATEGORY 类别下的帖子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.tags.TAG&lt;/td&gt;
        &lt;td&gt;TAG 标签下的帖子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;site.[CONFIGURATION_DATA]&lt;/td&gt;
        &lt;td&gt;_config.yml 设置的变量&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-28&quot;&gt;页面变量&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;变量&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.content&lt;/td&gt;
        &lt;td&gt;页面内容的源码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.title&lt;/td&gt;
        &lt;td&gt;页面的标题&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.excerpt&lt;/td&gt;
        &lt;td&gt;页面摘要的源码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.url&lt;/td&gt;
        &lt;td&gt;相对路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.date&lt;/td&gt;
        &lt;td&gt;帖子的日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.id&lt;/td&gt;
        &lt;td&gt;帖子的唯一标识码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.categories&lt;/td&gt;
        &lt;td&gt;这个帖子所属的 Categories&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.tags&lt;/td&gt;
        &lt;td&gt;这个 Post 所属的所有 tags&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;page.path&lt;/td&gt;
        &lt;td&gt;Post 或者 Page 的源文件地址&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-29&quot;&gt;分页器&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;变量&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.per_page&lt;/td&gt;
        &lt;td&gt;每一页Posts的数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.posts&lt;/td&gt;
        &lt;td&gt;这一页可用的Posts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.total_posts&lt;/td&gt;
        &lt;td&gt;Posts 的总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.total_pages&lt;/td&gt;
        &lt;td&gt;Pages 的总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.page&lt;/td&gt;
        &lt;td&gt;当前页号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.previous_page&lt;/td&gt;
        &lt;td&gt;前一页的页号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.previous_page_path&lt;/td&gt;
        &lt;td&gt;前一页的地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.next_page&lt;/td&gt;
        &lt;td&gt;下一页的页号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;paginator.next_page_path&lt;/td&gt;
        &lt;td&gt;下一页的地址&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-30&quot;&gt;模板&lt;/h3&gt;

&lt;h4 id=&quot;section-31&quot;&gt;过滤器&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;过滤器&lt;/code&gt;是一个简便的工具, 用于对输出数据进行处理&lt;/p&gt;

&lt;p&gt;详细说明请查看相关文档 &lt;a href=&quot;https://docs.shopify.com/themes/liquid/filters&quot;&gt;Liquid Filter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-32&quot;&gt;标签&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;标签&lt;/code&gt;是一个表示程序逻辑的工具, 告诉模板处理逻辑&lt;/p&gt;

&lt;p&gt;详细说明请看相关文档 &lt;a href=&quot;https://docs.shopify.com/themes/liquid/tags&quot;&gt;Liquid tag&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-33&quot;&gt;永久链接&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;永久链接&lt;/code&gt;是用来设置文章的URL链接格式的&lt;/p&gt;

&lt;h4 id=&quot;section-34&quot;&gt;模板变量&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;变量名&lt;/td&gt;
        &lt;td&gt;说明&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;year&lt;/td&gt;
        &lt;td&gt;年份&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;month&lt;/td&gt;
        &lt;td&gt;月份，格式如 `01, 10`&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;i_month&lt;/td&gt;
        &lt;td&gt;月份，格式如 `1, 10`&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;day&lt;/td&gt;
        &lt;td&gt;日期，格式如 `01, 20`&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;i_day&lt;/td&gt;
        &lt;td&gt;日期，格式如 `1, 20`&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;title&lt;/td&gt;
        &lt;td&gt;标题&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;categories&lt;/td&gt;
        &lt;td&gt;目录&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-35&quot;&gt;链接类型&lt;/h4&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;链接类型&lt;/td&gt;
        &lt;td&gt;URL 模板&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;date&lt;/td&gt;
        &lt;td&gt;/:categories/:year/:month/:day/:title.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;pretty&lt;/td&gt;
        &lt;td&gt;/:categories/:year/:month/:day/:title/&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;none&lt;/td&gt;
        &lt;td&gt;/:categories/:title.html&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-36&quot;&gt;举例&lt;/h4&gt;

&lt;p&gt;比如文件名： &lt;code class=&quot;highlighter-rouge&quot;&gt;/2009-04-29-slap-chop.textile&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;设置&lt;/td&gt;
        &lt;td&gt;对应的 URL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;没有配置或 permalink: date&lt;/td&gt;
        &lt;td&gt;/2009/04/29/slap-chop.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;permalink: pretty&lt;/td&gt;
        &lt;td&gt;/2009/04/29/slap-chop/index.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;permalink: /:month-:day-:year/:title.html&lt;/td&gt;
        &lt;td&gt;/04-29-2009/slap-chop.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;permalink: /blog/:year/:month/:day/:title&lt;/td&gt;
        &lt;td&gt;/blog/2009/04/29/slap-chop/index.html&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-37&quot;&gt;分页&lt;/h3&gt;

&lt;h4 id=&quot;section-38&quot;&gt;开启分页&lt;/h4&gt;

&lt;p&gt;开启分页功能很简单，只需要在 _config.yml里边加一行，并填写每页需要几行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;paginate: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下边是对需要带有分页页面的配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;paginate_path: &quot;blog/page:num&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;blog/index.html将会读取这个设置，把他传给每个分页页面，然后从第 2 页开始输出到 blog/page:num ， :num 是页码。如果有 12 篇文章并且做如下配置 paginate: 5 ， Jekyll会将前 5 篇文章写入 blog/index.html ，把接下来的 5 篇文章写入 blog/page2/index.html，最后 2 篇写入 blog/page3/index.html。&lt;/p&gt;

&lt;h4 id=&quot;section-39&quot;&gt;分页例子&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;paginator.total_pages&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pagination&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;paginator.previous_page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ paginator.previous_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;amp;laquo;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Prev&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;span&amp;gt;&amp;amp;laquo;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Prev&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(1..paginator.total_pages)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;paginator.page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;em&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&amp;lt;/em&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;elsif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ &#39;/index.html&#39; | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endfor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;paginator.next_page&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{{ paginator.next_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;Next&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;raquo;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;span&amp;gt;Next&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;raquo;&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-40&quot;&gt;插件&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyll.bootcss.com/docs/plugins/&quot;&gt;=====&amp;gt; JUMP &amp;lt;=====&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
        <pubDate>Fri, 25 Mar 2016 08:56:00 +0800</pubDate>
        <link>/2016/03/25/jekyll-study/</link>
        <guid isPermaLink="true">/2016/03/25/jekyll-study/</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
