<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SCH</title>
    <description>苏灿灏的博客 大数据爱好者</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 31 Mar 2016 13:52:54 +0800</pubDate>
    <lastBuildDate>Thu, 31 Mar 2016 13:52:54 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Combinations</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinations&quot; id=&quot;markdown-toc-combinations&quot;&gt;Combinations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinations&quot;&gt;Combinations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombine( n, 1, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}
public static void helperCombine( 
        int n, int t, int k, List&amp;lt;Integer&amp;gt; tmpRes, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res ) {
    // 约束条件
    if( t &amp;gt; n ) {
        return;
    }
    // 不选取当前值
    helperCombine( n, t+1, k, tmpRes, res );
    
    // 选取当前值
    tmpRes.add( t );
    if( k-1 == 0 ) {    // 获得一个结果
        res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
    } else {            // 进入下一层
        helperCombine( n, t+1, k-1, tmpRes, res );
    }
    tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于[1…n]中的每一个元素, 可取可不取&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;放在方法头部更容易理解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-Combinations/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-Combinations/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>CombinationSum(II)(III)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum&quot; id=&quot;markdown-toc-combinationsum&quot;&gt;CombinationSum&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum-ii&quot; id=&quot;markdown-toc-combinationsum-ii&quot;&gt;CombinationSum II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum-iii&quot; id=&quot;markdown-toc-combinationsum-iii&quot;&gt;CombinationSum III&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinationsum&quot;&gt;CombinationSum&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;

  &lt;p&gt;The same repeated number may be chosen from C unlimited number of times.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
    &lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, &amp;gt; a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example, given candidate set 2,3,6,7 and target 7,
A solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[7]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 2, 3]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum( 
        int[] candidates, int target ) {
    // 排序, 后面才可以进行剪枝
    Arrays.sort( candidates );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombinationSum2( 
            candidates, target, 0, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperCombinationSum2(
        int[] candidates, int target, int t, List&amp;lt;Integer&amp;gt; tmpRes, 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
    // 约束条件
    if( t == candidates.length ) {
        return;
    }
    // 剪枝
    if( candidates[t] &amp;gt; target ) {
        return;
    }
    
    // 遍历解空间
    int i = 0;
    for( ; i*candidates[t] &amp;lt;= target; ++i ) {
        if( i != 0 ) tmpRes.add( candidates[t] );
        if( i*candidates[t] == target ) {
            res.add( new ArrayList&amp;lt;Integer&amp;gt;( tmpRes) );
        } else {
            helperCombinationSum2( candidates, 
            	target-i*candidates[t], t+1, tmpRes, res );
        }
    }
    while( i-- &amp;gt; 1 )
        tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于candidates数组中的每一个值, 可以无限重复取, 但是实际上只要取到一定程度就就可以结束了, 结束条件: i*candidates[t] &amp;gt; target, 也就是取[0…i]的情况, [i+1…∞]不取.&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;combinationsum-ii&quot;&gt;CombinationSum II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;

  &lt;p&gt;Each number in C may only be used once in the combination.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
    &lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example, given candidate set 10,1,2,7,6,1,5 and target 8,&lt;/p&gt;

  &lt;p&gt;A solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 7]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 5]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 6]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 1, 6]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2( 
		int[] candidates, int target ) {
	// 排序, 后面才可以进行剪枝
	Arrays.sort( candidates );
	List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
	helperCombinationSum( 
			candidates, target, 0, new ArrayList&amp;lt;Integer&amp;gt;(), res );
	return res;
}

private static void helperCombinationSum(
		int[] candidates, int target, int t, List&amp;lt;Integer&amp;gt; tmpRes, 
		List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
	if( t == candidates.length ) {
		return;
	}
	// 剪枝
	if( candidates[t] &amp;gt; target ) {
		return;
	}
	
	// 统计重复元素个数
	int repeatCount = 0;
	while( repeatCount+t &amp;lt; candidates.length &amp;amp;&amp;amp; 
			candidates[t] == candidates[t+repeatCount])
		++repeatCount;
	
	// 遍历解空间
	int i = 0;
	for( ; i &amp;lt;= repeatCount &amp;amp;&amp;amp; i*candidates[t] &amp;lt;= target; ++i ) {
		if( i != 0 ) tmpRes.add( candidates[t] );
		if( i*candidates[t] == target ) {
			res.add( new ArrayList&amp;lt;Integer&amp;gt;( tmpRes) );
		} else {
			helperCombinationSum( candidates, 
			    target-i*candidates[t], t+repeatCount, tmpRes, res );
		}
	}
	while( i-- &amp;gt; 1 )
		tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 同CombinationSum一样. 不一样的地方: CombinationSum中的每个元素取[0,∞]个, 这里每个元素取[0…R]个, R表示元素的重复个数, 所以代码里面就多了限制条件: &lt;code class=&quot;highlighter-rouge&quot;&gt;i &amp;lt;= repeatCount&lt;/code&gt; 而且进入下一层要跨越重复元素: &lt;code class=&quot;highlighter-rouge&quot;&gt;t+repeatCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型, 思考新问题中&lt;code class=&quot;highlighter-rouge&quot;&gt;影响因素&lt;/code&gt;对结果产生的影响, 并且从原有模型中调整得到解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;combinationsum-iii&quot;&gt;CombinationSum III&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;

  &lt;p&gt;Ensure that numbers within the set are sorted in ascending order.&lt;/p&gt;

  &lt;p&gt;Example 1:&lt;/p&gt;

  &lt;p&gt;Input: k = 3, n = 7&lt;/p&gt;

  &lt;p&gt;Output:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,2,4]]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;Example 2:&lt;/p&gt;

  &lt;p&gt;Input: k = 3, n = 9&lt;/p&gt;

  &lt;p&gt;Output:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,2,6], [1,3,5], [2,3,4]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-6&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombinationSum3( n, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperCombinationSum3( int n, int k, List&amp;lt;Integer&amp;gt; tmpRes, 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
    // 约束条件
    if( k &amp;lt;= 0 || n &amp;lt;= 0 ) {
        return;
    }
    
    // 保证结果子集中不可能出现重复元素
    int i = tmpRes.size()==0 ? 1 : tmpRes.get(tmpRes.size()-1)+1;
    for( ; i &amp;lt;= 9; ++i ) {
        tmpRes.add( i );
        if( n-i == 0 &amp;amp;&amp;amp; k-1 == 0 ) {
            res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
        } else {
            helperCombinationSum3( n-i, k-1, tmpRes, res );
        }
        tmpRes.remove( tmpRes.size()-1 );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 本质上跟上面两题都是一样的. 不同的地方就是: &lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;解空间的遍历方式&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-CombinationSum(II)(III)/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-CombinationSum(II)(III)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>进程的查看</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ps&quot; id=&quot;markdown-toc-ps&quot;&gt;ps指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-1&quot; id=&quot;markdown-toc-ps-1&quot;&gt;ps参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-2&quot; id=&quot;markdown-toc-ps-2&quot;&gt;ps使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#t-o-p&quot; id=&quot;markdown-toc-t-o-p&quot;&gt;t-o-p指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-1&quot; id=&quot;markdown-toc-t-o-p-1&quot;&gt;t-o-p参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-2&quot; id=&quot;markdown-toc-t-o-p-2&quot;&gt;t-o-p程序指令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-3&quot; id=&quot;markdown-toc-t-o-p-3&quot;&gt;t-o-p使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pstree&quot; id=&quot;markdown-toc-pstree&quot;&gt;pstree指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-1&quot; id=&quot;markdown-toc-pstree-1&quot;&gt;pstree参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-2&quot; id=&quot;markdown-toc-pstree-2&quot;&gt;pstree使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps&quot;&gt;ps指令&lt;/h3&gt;

&lt;h4 id=&quot;ps-1&quot;&gt;ps参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;显示所有的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;排除与终端有关的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;指定特定用户的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;显示更完整的信息, 与a参数一起使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;长格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;工作格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;完整格式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;ps-2&quot;&gt;ps使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看与bash相关的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps -l
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-l.png&quot; alt=&quot;ps-l&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;F&lt;/td&gt;
          &lt;td&gt;4表示进程权限为root, 1表示进程只能fork, 不能执行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;S&lt;/td&gt;
          &lt;td&gt;进程的STATE, R-&amp;gt;运行, S-&amp;gt;睡眠, D-&amp;gt;阻塞, T-&amp;gt;停止, Z-&amp;gt;僵尸&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;UID&lt;/td&gt;
          &lt;td&gt;用户ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PPID&lt;/td&gt;
          &lt;td&gt;父进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;C&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PRI/NI&lt;/td&gt;
          &lt;td&gt;进程优先级相关, 越小优先级越高&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ADDR&lt;/td&gt;
          &lt;td&gt;进程内存地址&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SZ&lt;/td&gt;
          &lt;td&gt;消耗的内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;WCHAN&lt;/td&gt;
          &lt;td&gt;运行状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;CMD&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统所有的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-aux.png&quot; alt=&quot;ps-aux&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VSZ&lt;/td&gt;
          &lt;td&gt;虚拟内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RSS&lt;/td&gt;
          &lt;td&gt;内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;STAT&lt;/td&gt;
          &lt;td&gt;进程状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;START&lt;/td&gt;
          &lt;td&gt;进程启动时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统某进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux | egrep &#39;xrgsu&#39;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-egrep.png&quot; alt=&quot;ps-egrep&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;t-o-p&quot;&gt;t-o-p指令&lt;/h3&gt;

&lt;h4 id=&quot;t-o-p-1&quot;&gt;t-o-p参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;更新频率, 以秒为单位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b&lt;/td&gt;
      &lt;td&gt;批处理, 通常配合数据流重定向&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;与-b配合, 指定批处理总次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;检测指定进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-2&quot;&gt;t-o-p程序指令&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;查看top程序指令帮助&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;按照CPU使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;按照内存使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;按照PID排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;按照CPU运行总时长排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;kill进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;重新给进程nice值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;q&lt;/td&gt;
      &lt;td&gt;退出top&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-3&quot;&gt;t-o-p使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每隔2秒更新一次资源状态&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -d 2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-top-d2.png&quot; alt=&quot;top-d2&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PR/NI&lt;/td&gt;
          &lt;td&gt;优先级&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VIRT&lt;/td&gt;
          &lt;td&gt;虚拟内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RES&lt;/td&gt;
          &lt;td&gt;内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SHR&lt;/td&gt;
          &lt;td&gt;共享内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME+&lt;/td&gt;
          &lt;td&gt;CPU使用累积时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把资源状态结果输出到文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -b -n 2 &amp;gt; /tmp/top.txt
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pstree&quot;&gt;pstree指令&lt;/h3&gt;

&lt;h4 id=&quot;pstree-1&quot;&gt;pstree参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;以ASCII字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-U&lt;/td&gt;
      &lt;td&gt;以UTF8字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;显示进程所属用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;显示进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;pstree-2&quot;&gt;pstree使用实例&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pstree -Uup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/linux/linux-pstree-Uup.png&quot; alt=&quot;pstree-Uup&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/linux-process-check/</link>
        <guid isPermaLink="true">/2016/03/30/linux-process-check/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Permutations(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations&quot; id=&quot;markdown-toc-permutations&quot;&gt;Permutations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations-ii&quot; id=&quot;markdown-toc-permutations-ii&quot;&gt;Permutations II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;permutations&quot;&gt;Permutations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,2,3] have the following permutations:&lt;/p&gt;

  &lt;p&gt;[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute( int[] nums ) {
    helperPermute( nums, 0 );
    return res;
}
private static void helperPermute( int[] nums, int t ) {
    if( t == nums.length ) {
        // 构造一个结果
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        
        // 加入结果集
        res.add( tmpRes );
    } else {
        for( int i = t; i &amp;lt; nums.length; ++i ) {
            swap( nums, t, i);
            helperPermute( nums, t+1 );
            swap( nums, t, i);
        }
    }
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个集合的全排列, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;排列树&lt;/code&gt;问题.&lt;/p&gt;

&lt;p&gt;代码可以这样理解, 集合S的全排列由以下的结果组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S[1]+全排列( S[2…n] )&lt;/li&gt;
  &lt;li&gt;S[2]+全排列( S[1, 3…n] )&lt;/li&gt;
  &lt;li&gt;S[3]+全排列( S[2, 1, 4…n] )&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;S[n]+全排列( S[1…n-1] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是把S的中每一个元素都提取到第一位, 剩下的元素做全排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 为什么要swap2次? 因为我们要保证在处理完一次结果之后, 要恢复数组的原始状态, 这样下一次处理的时候才能正确把下一个元素交换到第一个位置来.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的全排列&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个处理过程是迭代形式的, 而且迭代过程有严格的状态要求, 那么就十分需要注意子处理过程所带来的影响.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;permutations-ii&quot;&gt;Permutations II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

  &lt;p&gt;[1,1,2], [1,2,1], and [2,1,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique( int[] nums ) {
    Arrays.sort( nums );
    helperPermuteUnique( nums, 0, nums.length-1 );
    return res;
}
private static void helperPermuteUnique( int[] nums, int i, int j ) {
    if( i == j ) {
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        res.add( tmpRes );
    } 
    for( int k = i; k &amp;lt;= j; ++k ) {
        if( findSame(nums, i, k) ) continue;
        swap( nums, i, k );
        helperPermuteUnique( nums, i+1, j );
        swap( nums, i, k );
    }
}

private static boolean findSame( int[] nums, int i, int j ) {
    for( int k = i; k &amp;lt; j; ++k )
        if( nums[j] == nums[k] ) return true;
    return false;
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 对于有重复元素集合的全排列, 可以用上面无重复元素的全排列来解决, 区别就是我们在这个基础上还要排除一些重复的全排列, 那么我们需要思考的问题是: 按照无重复元素的全排列处理过程, 如何消除重复元素带来的影响? 我们知道全排列的一次处理过程就是把每一个元素都搬到第一个位置, 然后做剩余元素的全排列, 所以我们只需要判断当前元素跟前面的元素有没有重复, 有重复的话就是已经处理过的, 直接跳过.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型去思考问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-permutations(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-permutations(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Next Permutation</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically &amp;gt; next greater permutation of numbers.&lt;/p&gt;

  &lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible &amp;gt; order (ie, sorted in ascending order).&lt;/p&gt;

  &lt;p&gt;The replacement must be in-place, do not allocate extra memory.&lt;/p&gt;

  &lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding &amp;gt; outputs are in the right-hand column.&lt;/p&gt;

  &lt;p&gt;1,2,3 → 1,3,2&lt;/p&gt;

  &lt;p&gt;3,2,1 → 1,2,3&lt;/p&gt;

  &lt;p&gt;1,1,5 → 1,5,1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void nextPermutation( int[] nums ) {

    // 从后往前找到第一个递增对 [i, i+1]
    int i = nums.length-2;
    for( ; i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i+1]; --i );

    // 已经不存在递增对, 所有排列已经列举完了, 这里重新开始
    if( i &amp;lt; 0 ) {
        reverse( nums, 0, nums.length-1 );
        return;
    }

    // 从后往前找到第一个 [j] &amp;gt; [i]
    int j = nums.length-1;
    for( ; j &amp;gt; i &amp;amp;&amp;amp; nums[j] &amp;lt;= nums[i]; --j );

    // 构造下一个全排列
    swap( nums, i, j );
    i = i + 1;
    j = nums.length-1;
    reverse( nums, i, j );
}
private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
private static void reverse( int[] nums, int i, int j ) {
    while( i &amp;lt; j ) {
        swap( nums, i++, j-- );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个排列的下一个排列, 从数值上看, 就是找到下一个值, 使得下一个值&lt;code class=&quot;highlighter-rouge&quot;&gt;比当前值大&lt;/code&gt;并且要&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;. 所以我们可以从数值的低位部分入手, 因为改变低位对数值大小的影响最小, 也就满足了&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;这个条件. 现在考虑一个例子:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, … , A&lt;sub&gt;K&lt;/sub&gt;, A&lt;sub&gt;K+1&lt;/sub&gt;, …, A&lt;sub&gt;N&lt;/sub&gt;]&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;K+1&lt;/sub&gt; &amp;gt; … &amp;gt; A&lt;sub&gt;N&lt;/sub&gt; ( 1 &amp;lt; K &amp;lt; N, 也就是[K+1…N]递减 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于[K+1…N]这部分是递减的, 那么在这部分做修改是不可能构造出一个比当前值还大的值, 所以就要第[K]位加进来, 也就是对[K…N]这部分做修改, 那么该如何改呢?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在[K+1…N]中找一个刚好比[K]大的值, 与[K]交换, 才能构造出一个比当前值大的值, 所以就可以在[K+1…N]中由后往前找合适的值([K+1…N]是递减的, 所以由后往前找)&lt;/li&gt;
  &lt;li&gt;找到合适的值之后与[K]交换, 交换之后[K+1…N]还是递减的&lt;/li&gt;
  &lt;li&gt;修改[K+1…N]这部分变为最小值, 因为[K+1…N]是递减的, 翻转以下就可以了&lt;/li&gt;
  &lt;li&gt;得到下一个全排列的值&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 求下一个排列的问题可以转化为数值的问题, 然后又要想到数值的变化影响因素中, 低位的影响是最小的, 所以思考点要转移到如何修改低位部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;专注问题的思考点, 并且不断转换思考点, 直到问题清晰可解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-next-permutation/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-next-permutation/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>NQueens(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#nqueens&quot; id=&quot;markdown-toc-nqueens&quot;&gt;NQueens&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nqueens-ii&quot; id=&quot;markdown-toc-nqueens-ii&quot;&gt;NQueens II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nqueens&quot;&gt;NQueens&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such &amp;gt; that no two queens attack each other.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2012/03/8-queens.png&quot; alt=&quot;8-Queens&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;

  &lt;p&gt;Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.
For example,
There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueensRecursion( int n ) {
      List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      // 创建棋盘: board[i]表示第i行第board[i]列
      int[] board = new int[n];
      // 初始化棋盘, -1表示没有棋子
      Arrays.fill(board, -1);
      // 回溯查找解
      helperNQueens( 0, board, res );
      return res;
  }

  private static void helperNQueens(int t, int[] board, List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res) {
      if( t == board.length ) {
          res.add( newBoard(board) );
          return;
      }
      for( int i = 0; i &amp;lt; board.length; ++i ) {
          board[t] = i;
          if( constraints( board, t ) )
              helperNQueens( t+1, board, res );
      }
  }

  private static boolean constraints(int[] board, int t) {
      for( int i = 0; i &amp;lt; t; ++i ) {
          if( (board[i] == board[t]) ||
                  (t-i == board[t]-board[i] || t-i == board[i]-board[t]) )
              return false;
      }
      return true;
  }

  /*
   * 返回棋盘的表示形式, 类型为List&amp;lt;String&amp;gt;
   */
  private static List&amp;lt;String&amp;gt; newBoard(int[] board) {
      List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      int n = board.length;
      char[][] newBoard = new char[n][n];
      for( int i = 0; i &amp;lt; n; ++i )
          Arrays.fill(newBoard[i], &#39;.&#39;);
      for( int i = 0; i &amp;lt; n; ++i ) {
          newBoard[i][board[i]] = &#39;Q&#39;;
          StringBuilder sb = new StringBuilder();
          for( char c : newBoard[i] ) sb.append(c);
          res.add( sb.toString() );
      }
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考过程: N皇后问题属于经典的题目, 用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;来解决&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 难点主要有两个, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;棋盘的表示&lt;/code&gt;, 另一个是皇后之间的&lt;code class=&quot;highlighter-rouge&quot;&gt;冲突判断&lt;/code&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;棋盘的表示&lt;/code&gt;要建立在对问题约束条件的理解之上. 棋盘之中皇后之间不能处于同一行, 也不能处于同一列, 那么我们可以用一个数组board来表示这个棋盘.&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;数组下标表示棋盘中的行值&lt;/li&gt;
        &lt;li&gt;数组的值表示棋盘中的列值&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;冲突判断&lt;/code&gt;有3个条件:&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;皇后不能处于同一行: 不需要显示判断, 因为我们以行作为递归, 皇后不可能出现在同一行&lt;/li&gt;
        &lt;li&gt;皇后不能处于同一列: 根据 board[i] == board[j] 作为判断&lt;/li&gt;
        &lt;li&gt;皇后不能处于同一斜线: 根据 j-i == abs(board[j]-board[i]) (j&amp;gt;i)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;斜线的判断可能比较难以理解: 意思是行值差与列值差相等表示皇后在同一斜线上.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的棋盘&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;善于观察题目的限制条件, 从而构造出合适的数据结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueensIteration( int n ) {
      List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      // 创建棋盘: board[i]表示第i行第board[i]列
      int[] board = new int[n];

      // 初始化第0行的状态
      board[0] = -1;
      // t表示目前处于第t行
      int t = 0;
      while( t &amp;gt;= 0 ) {
          // 查找第t行皇后的存放位置
          ++board[t];
          while( board[t] &amp;lt; n &amp;amp;&amp;amp; !constraints( board, t ) ) ++board[t];

          // 找到第t行皇后的存放位置就进入下一行
          if( board[t] &amp;lt; n ) {
              if( t == n-1 ) {
                  res.add( newBoard(board) );
              } else {
                  ++t;
                  board[t] = -1;
              }
          } else {
              --t;
          }
      }
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;nqueens-ii&quot;&gt;NQueens II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;

  &lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.
&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2012/03/8-queens.png&quot; alt=&quot;8-Queens&quot; /&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;该题目的算法与上一道题的一模一样, 只需要在相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;递归版本&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;迭代版本&lt;/code&gt;中找到可行解的时候统计数量即可&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-NQueens(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-NQueens(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Subsets(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets&quot; id=&quot;markdown-toc-subsets&quot;&gt;Subsets&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets-ii&quot; id=&quot;markdown-toc-subsets-ii&quot;&gt;Subsets II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subsets&quot;&gt;Subsets&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,3], a solution is:
    [
      [3],
      [1],
      [2],
      [1,2,3],
      [1,3],
      [2,3],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsRecursion( int[] nums ) {
      Arrays.sort( nums );
      helperRecursion( nums, 0, new ArrayList&amp;lt;Integer&amp;gt;() );
      return res;
  }
  private static void helperRecursion( int[] nums, int t, List&amp;lt;Integer&amp;gt; tmpRes ) {
      // 获得一个子集
      if( t == nums.length ) {
          res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
          return;
      }
      // 不选择当前深度的节点
      helperRecursion( nums, t+1, tmpRes );

      // 选择当前深度的节点
      tmpRes.add( nums[t] );
      helperRecursion( nums, t+1, tmpRes );
      tmpRes.remove( tmpRes.size()-1 );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 求一个集合的所有子集, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;子集树&lt;/code&gt;问题, 而且这棵树是一棵完全二叉树, 利用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的递归写法可以很容易的写出代码.&lt;/p&gt;

    &lt;p&gt;处理过程: 利用一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;表示当前树的深度, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;深度的时候, 有两种选择, 一种是不选择当前深度的节点并且进入下一层, 另一种是选择当前深度的节点并且进入下一层. 其终止条件就是到达叶子节点.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetIteration( int[] nums ) {
      Arrays.sort( nums );
      List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        
      // 初始状态: 结果集中包含了子集: 空集
      res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
        
      // 构造过程: 动态生成每一个子集并且加入结果集
      for( int i = 0; i &amp;lt; nums.length; ++i ) {
          int subsetCount = res.size();
          for( int j = 0; j &amp;lt; subsetCount; ++j ) {
              List&amp;lt;Integer&amp;gt; newSubset = new ArrayList&amp;lt;&amp;gt;( res.get(j) );
              newSubset.add( nums[i] );
              res.add( newSubset );
          }
      }
        
      // 结束状态: 返回结果集
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 在思考问题解之前, 可以先思考另外一个问题: 对结果集产生影响的基本因素是什么? 基本因素就是数组中的元素. 再思考一个问题: 基本因素是如何影响结果集的? 当原本数组加入一个新的元素的时候, 由于元素在子集中可选可不选, 不选的话不会对原本的结果集产生影响, 选择的话原本的结果集会多添加一些新子集, 而且这些新子集=旧子集+新元素&lt;/p&gt;

    &lt;p&gt;处理过程: 首先, 对于任何的数组, 其结果集中一定有一个空集; 之后对每一个元素, 产生一些新子集: 新子集=旧子集+新元素, 并且把新子集加入结果集中; 最后返回结果集.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度O(2^n), 空间复杂度O(1): 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于有处理模型的问题, 我们很容易想到解决方案; 但是有时候我们并不知道处理模型是什么, 我们应该从小方面入手, 思考问题的基本因素, 从基本因素展开分析, 从而构造出一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;subsets-ii&quot;&gt;Subsets II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,2], a solution is:
    [
      [2],
      [1],
      [1,2,2],
      [2,2],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsIteration( int[] nums ) {
    Arrays.sort( nums );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
    // 初始状态: 结果集中包含了子集: 空集
    res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
    
    // 构造过程: 对每一个元素构造出新子集并加入结果集
    for( int i = 0; i &amp;lt; nums.length; ) {
        // 统计重复个数
        int repeatNum = 0;
        while( i+repeatNum &amp;lt; nums.length &amp;amp;&amp;amp;
                nums[i] == nums[repeatNum+i] ) ++repeatNum;
        // 构造子集
        int subsetCount = res.size();
        for( int j = 0; j &amp;lt; subsetCount; ++j ) {
            List&amp;lt;Integer&amp;gt; subset = new ArrayList&amp;lt;Integer&amp;gt;( res.get(j) );
            for( int k = 0; k &amp;lt; repeatNum; ++k ) {
                subset.add( nums[i] );
                res.add( new ArrayList&amp;lt;Integer&amp;gt;( subset ) );
            }
        }
        i += repeatNum;
    }
    
    // 结束状态: 返回结果集
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 其基本思考过程同上面的Subsets迭代方式差不多, 不同点在于出现了重复元素, 那么还是一样, 我们思考重复元素对原始结果集的影响是什么? 思考这样一个例子[ 1, 2, 2 ], 当处理完元素[1]的时候, 我们得到的结果集是{ {}, {1} }, 接下来对于重复元素[2], 我们可以构造出来的新子集=旧子集+(1或2)个[2], 也就是说, 对于重复元素, 我们可以选择1-n个重复元素加入旧子集形成新子集, 对于重复元素的解决方案就出来了, 最后可以得到上面的代码&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;还是一样, 对于一个新的问题, 我们应该从基本的角度去思考, 从而展开到一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/29/leetcode-subsets(II)/</link>
        <guid isPermaLink="true">/2016/03/29/leetcode-subsets(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>find指令学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#find&quot; id=&quot;markdown-toc-find&quot;&gt;find指令的用途&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#find-1&quot; id=&quot;markdown-toc-find-1&quot;&gt;find指令常用参数说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#find-2&quot; id=&quot;markdown-toc-find-2&quot;&gt;find指令常用例子&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;查找前5个最大的文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;查找某一段时间修改过的文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;在多个目录中查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;排除指定目录查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;按照文件类型查找&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;重复文件查找&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find&quot;&gt;find指令的用途&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在目录层次中查找满足特定要求的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;find-1&quot;&gt;find指令常用参数说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-type c: 按照文件类型c查找, 文件类型c说明如下:
    &lt;ul&gt;
      &lt;li&gt;b: 块设备文件&lt;/li&gt;
      &lt;li&gt;c: 字符设备文件&lt;/li&gt;
      &lt;li&gt;d: 目录&lt;/li&gt;
      &lt;li&gt;p: 管道文件&lt;/li&gt;
      &lt;li&gt;f: 普通文件&lt;/li&gt;
      &lt;li&gt;l: 符号链接文件&lt;/li&gt;
      &lt;li&gt;s: 套接字文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-name fname: 按照fname(不加目录前缀)查找文件&lt;/li&gt;
  &lt;li&gt;-exec command: 对查找到的文件进行指令处理, 注意结尾以’;’结束&lt;/li&gt;
  &lt;li&gt;-mmin n: 查找n分钟之前修改过的文件&lt;/li&gt;
  &lt;li&gt;-mtime n: 查找n天之前修改过的文件&lt;/li&gt;
  &lt;li&gt;-xdev: 只查找当前的文件系统&lt;/li&gt;
  &lt;li&gt;-printf: 如果find指令返回值为true, 指定格式输出结果&lt;/li&gt;
  &lt;li&gt;-prune: 排除指定的搜索范围&lt;/li&gt;
  &lt;li&gt;-o: 或者&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;find-2&quot;&gt;find指令常用例子&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;查找前5个最大的文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -type f -exec du {} \; | sort -n | tail -n 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-exec du表示对每一个找到的文件都计算文件大小&lt;/p&gt;

  &lt;p&gt;sort -n表示对所有文件按大小升序排序&lt;/p&gt;

  &lt;p&gt;tail -n 5表示取最后5个文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;查找某一段时间修改过的文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -mmin +60 -mmin -120 -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;-mmin +60: 表示前60分钟之前&lt;/p&gt;

  &lt;p&gt;-mmin -120: 表示前120分钟之后&lt;/p&gt;

  &lt;p&gt;所以该指令就是查找2个小时之前的1小时内修改过的文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;在多个目录中查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find /etc /var /mnt /media -xdev -mmin -5 -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令在/etc, /var, /mnt, /media这些目录下查找&lt;/p&gt;

  &lt;p&gt;-xdev表示只对该文件系统查找&lt;/p&gt;

  &lt;p&gt;-mmin -5 表示5分钟之内修改过的文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;排除指定目录查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / \( -name proc -o -name sys \) -prune -o -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示对根目录查找, 但是排除 /proc 和 /sys这两个目录&lt;/p&gt;

  &lt;p&gt;-prune -o表示对满足括号中条件的目录排除在外&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;按照文件类型查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -name &quot;*.png&quot; -o -name &quot;*.jpg&quot; -o -name &quot;*.gif&quot; -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示在当前目录中查找格式为png, jpg, gif的文件&lt;/p&gt;

  &lt;p&gt;-o 表示或者&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-5&quot;&gt;重复文件查找&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type f -exec md5sum &#39;{}&#39; &#39;;&#39; | sort | uniq --all-repeated=separate -w 24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该指令表示对当前目录下的文件计算MD5并通过前24位进行比较&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/28/linux-command-find/</link>
        <guid isPermaLink="true">/2016/03/28/linux-command-find/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>IP原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ip&quot; id=&quot;markdown-toc-ip&quot;&gt;IP地址分类&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-1&quot; id=&quot;markdown-toc-ip-1&quot;&gt;IP地址编址历史&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-2&quot; id=&quot;markdown-toc-ip-2&quot;&gt;IP地址分类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-3&quot; id=&quot;markdown-toc-ip-3&quot;&gt;IP常用地址&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-4&quot; id=&quot;markdown-toc-ip-4&quot;&gt;特殊IP地址&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-5&quot; id=&quot;markdown-toc-ip-5&quot;&gt;IP地址与硬件地址&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-6&quot; id=&quot;markdown-toc-ip-6&quot;&gt;IP地址与硬件地址的原理区别&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#arp&quot; id=&quot;markdown-toc-arp&quot;&gt;ARP协议&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-7&quot; id=&quot;markdown-toc-ip-7&quot;&gt;IP数据报格式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ip-8&quot; id=&quot;markdown-toc-ip-8&quot;&gt;IP首部格式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;报文段切割&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ip-9&quot; id=&quot;markdown-toc-ip-9&quot;&gt;IP层转发分组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip&quot;&gt;IP地址分类&lt;/h3&gt;

&lt;p&gt;IP地址唯一标识网络中某一个设备, 其定义如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP ::= { 网络号 : 主机号 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;ip-1&quot;&gt;IP地址编址历史&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;分类编址: IP地址可以划分为ABCDE五类, 可以参考下图&lt;/li&gt;
  &lt;li&gt;划分子网: 在分类编址的基础上定义了子网的概念和划分原理&lt;/li&gt;
  &lt;li&gt;无分类编址: 抛弃分类编址的方式, 重新定义编址方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ip-2&quot;&gt;IP地址分类&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-classification.jpg&quot; alt=&quot;IP分类编址&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ip-3&quot;&gt;IP常用地址&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-use-usually-classification.gif&quot; alt=&quot;IP常用地址&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;A类地址中减去2表示排除了网络号全0(表示&lt;code class=&quot;highlighter-rouge&quot;&gt;本网络&lt;/code&gt;)和网络号127(表示&lt;code class=&quot;highlighter-rouge&quot;&gt;环回地址&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;B类地址中减去1表示排除了128.0(保留)网络&lt;/li&gt;
    &lt;li&gt;C类地址中减去1表示排除了192.0.0(保留)网络&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ip-4&quot;&gt;特殊IP地址&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-use-rarely.jpg&quot; alt=&quot;特殊IP地址&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-5&quot;&gt;IP地址与硬件地址&lt;/h3&gt;

&lt;p&gt;IP地址唯一表示网络中的某一个设备, 硬件地址也是唯一表示某一个设备, 那么为什么需要两种地址呢?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是因为全世界有着各种各样的网络, 不同的网络使用不同的硬件地址, 为了使得这些异构网络之间能够通信, 就需要一个统一的规则来表示每个设备, 也就是IP地址了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ip-6&quot;&gt;IP地址与硬件地址的原理区别&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-ipAddress-and-macAddress.jpg&quot; alt=&quot;IP地址与硬件地址的原理区别&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;arp&quot;&gt;ARP协议&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ARP协议&lt;/code&gt;是用来找出IP地址对应的硬件地址, 还有一个协议是&lt;code class=&quot;highlighter-rouge&quot;&gt;RARP协议&lt;/code&gt;, 是用来找出硬件地址对应的IP地址, 这两个协议都是处于网络层中&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ARP协议&lt;/code&gt;的工作原理如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-arp.jpg&quot; alt=&quot;ARP协议的工作原理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ARP工作原理解释如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主机A在局域网中广播ARP请求分组&lt;/li&gt;
  &lt;li&gt;所有主机都受到ARP请求分组, 但是只有主机B响应分组&lt;/li&gt;
  &lt;li&gt;主机A收到主机B的响应分组, 在ARP高速缓存中记录主机B&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;主机A发送出ARP请求分组, 主机B会在ARP高速缓存中记录主机A, 这样可以避免主机B要找主机A的时候也要发出一个ARP请求分组, 减少了网络开销&lt;/li&gt;
    &lt;li&gt;ARP高速缓存中的记录是有生存时间的, 过了生存时间的记录就会自动删除, 这是基于网络中的硬件地址是动态变更这种情况考虑的, 例如主机B换了一个网络适配器, 其先前的地址也就无效了&lt;/li&gt;
    &lt;li&gt;ARP协议是解决同一个局域网内的主机中IP地址与硬件地址的映射问题&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-7&quot;&gt;IP数据报格式&lt;/h3&gt;

&lt;h4 id=&quot;ip-8&quot;&gt;IP首部格式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-header.jpg&quot; alt=&quot;IP数据报格式&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;版本: IP协议版本(IPv4, IPv6等)&lt;/li&gt;
  &lt;li&gt;首部长度: IP首部的字节长度, 范围为20~60&lt;/li&gt;
  &lt;li&gt;区分服务: 更多服务&lt;/li&gt;
  &lt;li&gt;总长度: IP数据报的长度, 范围为20~65535字节, 一般以太网使用的MTU(Maximum Transfer Unit)为1500, MTU表示IP数据报中数据部分的最大长度&lt;/li&gt;
  &lt;li&gt;标识: 报文段发生分片的时候使用, 接收端通过标识可以合并同一个标识的IP数据报&lt;/li&gt;
  &lt;li&gt;标志: 目前使用DF(Don’t Fragment)和MF(More Fragment)&lt;/li&gt;
  &lt;li&gt;片偏移: IP数据报合并时, 用来确认每一个IP数据报在原始报文段中的位置, 8个字节为单位&lt;/li&gt;
  &lt;li&gt;生存时间: IP数据报的生存时间, 目前一般表示跳数&lt;/li&gt;
  &lt;li&gt;协议: 表示IP数据报使用的协议, 例如: TCP, UDP, OSPF&lt;/li&gt;
  &lt;li&gt;首部检验和: 检验IP首部, 每一次路由转发后, 都会检验首部的正确性&lt;/li&gt;
  &lt;li&gt;源地址: 发送方IP地址&lt;/li&gt;
  &lt;li&gt;目的地址: 接收方IP地址&lt;/li&gt;
  &lt;li&gt;可选字段(长度可变)&lt;/li&gt;
  &lt;li&gt;填充: IP首部填充0, 知道满足以4个字节为单位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;报文段切割&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-data-split.png&quot; alt=&quot;IP数据报分片举例&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;解释如下:
原始题目中规定IP数据报的&lt;code class=&quot;highlighter-rouge&quot;&gt;MTU&lt;/code&gt;为1400, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;是以8个字节为单位, 我们发现8能够整除1400, 所以我们可以直接以1400个字节为切割单位, 分别切割出1400/1400/1000这样的3个数据, 然后分别计算&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;, 得到0/175/350, 这样把这些数据写到各自的首部中, 另外还需要给这3个数据一个共同的&lt;code class=&quot;highlighter-rouge&quot;&gt;标识&lt;/code&gt;(例如:12345).&lt;/p&gt;

  &lt;p&gt;这样切割之后, 接收端就可以根据&lt;code class=&quot;highlighter-rouge&quot;&gt;标识&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;片偏移&lt;/code&gt;来组合IP数据报, 得到原始的报文段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ip-9&quot;&gt;IP层转发分组&lt;/h3&gt;

&lt;p&gt;转发分组涉及两个概念: &lt;code class=&quot;highlighter-rouge&quot;&gt;路由&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;路由 ::= ( 目的网络地址, 下一跳地址 )
路由表 ::= 包含路由信息的表格
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一个IP数据报的转发都需要查询&lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;路由表&lt;/code&gt;如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/computer-network/ip-transfer-algorithm.jpg&quot; alt=&quot;IP层转发分组&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分组转发算法流程如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;从IP数据报首部中提取目的IP地址D, 并计算得到网络地址N&lt;/li&gt;
    &lt;li&gt;如果N就是与路由器直接相连的网络, 那么直接交付到目的主机, 否则执行(3)&lt;/li&gt;
    &lt;li&gt;如果路由表中有目的地址D的特定主机路由, 那么交付特定路由器, 否则执行(4)&lt;/li&gt;
    &lt;li&gt;如果路由表中有目的网络N的转发地址, 那么交付对应的路由器, 否则执行(5)&lt;/li&gt;
    &lt;li&gt;如果路由表中有默认路由, 那么交付默认路由器, 否则执行(6)&lt;/li&gt;
    &lt;li&gt;报告转发分组出错&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/27/computer-network-ip/</link>
        <guid isPermaLink="true">/2016/03/27/computer-network-ip/</guid>
        
        
        <category>计算机网络</category>
        
      </item>
    
      <item>
        <title>回溯法原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;回溯法定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;回溯法原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;回溯法算法框架&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;递归回溯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;迭代回溯&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;子集树&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;排列树&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;回溯法定义&lt;/h3&gt;

&lt;p&gt;回溯法是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;搜索算法&lt;/code&gt;, 可以系统地搜索一个问题的&lt;code class=&quot;highlighter-rouge&quot;&gt;所有解&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;任一解&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回溯法原理&lt;/h3&gt;

&lt;p&gt;回溯法的搜索原理是&lt;code class=&quot;highlighter-rouge&quot;&gt;深度优先搜索策略&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原理: &lt;strong&gt;首先定义问题的解空间&lt;/strong&gt;, 举个&lt;code class=&quot;highlighter-rouge&quot;&gt;0-1背包&lt;/code&gt;的例子, 假设只有两个东西, 那么解空间可以这样表示{(00),(01),(10),(11)}; &lt;strong&gt;其次组织解空间, 一般组织为树或者图&lt;/strong&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;0-1背包&lt;/code&gt;的解空间就变成了一棵完全二叉树; &lt;strong&gt;最后是开始搜索&lt;/strong&gt;, 过程是这样的: 从根节点出发, 以深搜方式搜索整个解空间. 根节点首先成为&lt;code class=&quot;highlighter-rouge&quot;&gt;活节点&lt;/code&gt;, 并且纵向移至下一个新节点, 新节点就成为了&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;无法再纵向移动, 那么就成为了&lt;code class=&quot;highlighter-rouge&quot;&gt;死节点&lt;/code&gt;, 此时就应该回溯到最近一个&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;处, 继续用以上的方式进入下一个扩展.&lt;/p&gt;

&lt;p&gt;回溯法以这种方式在解空间中搜索, 直到找到所要求的解活解空间中已经没有&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;为止&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法的步骤如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;针对所给问题, 定义问题的解空间&lt;/li&gt;
    &lt;li&gt;确定易于搜索的解空间结构&lt;/li&gt;
    &lt;li&gt;以深搜方式搜索解空间, 并在搜索过程中使用剪枝函数避免无效搜索&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;回溯法算法框架&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;递归回溯&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            x[ t ] = h( i );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;t 表示递归深度&lt;/li&gt;
    &lt;li&gt;n 表示解空间树的总深度&lt;/li&gt;
    &lt;li&gt;x 表示可行解&lt;/li&gt;
    &lt;li&gt;f(n,t) 表示当前&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;未搜索过的子树起始编号&lt;/li&gt;
    &lt;li&gt;g(n,t) 表示当前&lt;code class=&quot;highlighter-rouge&quot;&gt;活结点&lt;/code&gt;未搜索过的子树终止编号&lt;/li&gt;
    &lt;li&gt;constraint(t) 表示约束函数, 用于确认x[1…t]是否满足约束条件, 不满足条件可以剪枝&lt;/li&gt;
    &lt;li&gt;bound(t) 表示限界函数, 用于确认x[1…t]是否使目标函数越界, 使目标函数越界可以剪枝&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;迭代回溯&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void iterativeBackTrack() {
    int t = 1;
    while( t &amp;gt; 0 ) {
        if( f( n, t ) &amp;lt;= g( n, t ) ) {
            for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
                x[ t ] = h( i );
                if( constraint( t ) &amp;amp;&amp;amp; bound( t ) ) {
                    if( solution( t ) )	//表示有可行解
                        Output( x );
                    else
                        ++t;
                }
            }
        } else {
            --t;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;子集树&lt;/h4&gt;

&lt;p&gt;子集树定义:当所给的问题是从n个元素的集合中找出满足某种性质的子集时, 相应的解空间树称为子集树, 其解空间大小为O(2^n)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            x[ t ] = h( i );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;排列树&lt;/h4&gt;

&lt;p&gt;排列树定义:当所给的问题是从n个元素的集合中找出满足某种性质的排列时, 相应的解空间树称为排列树, 其解空间大小为O(n!)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void backTrack( int t ) {
    if( t &amp;gt; n ) {
        Output( x );
    } else {
        for( int i = f( n, t ); i &amp;lt;= g( n, t ); ++i ) {
            // swap表示交换元素
            swap( x[t], x[i] );
            if( constraint( t ) &amp;amp;&amp;amp; bound( t ) )
                backTrack( t+1 );
            swap( x[t], x[i] );
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 27 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/27/algorithm-backtracking/</link>
        <guid isPermaLink="true">/2016/03/27/algorithm-backtracking/</guid>
        
        
        <category>算法</category>
        
      </item>
    
  </channel>
</rss>
