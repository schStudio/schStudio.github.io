<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SCH</title>
    <description>苏灿灏的博客 大数据爱好者</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 05 Apr 2016 19:39:19 +0800</pubDate>
    <lastBuildDate>Tue, 05 Apr 2016 19:39:19 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Maximum Product Subarray</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#maximum-product-subarray&quot; id=&quot;markdown-toc-maximum-product-subarray&quot;&gt;Maximum Product Subarray&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;maximum-product-subarray&quot;&gt;Maximum Product Subarray&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;

  &lt;p&gt;For example, given the array &lt;code class=&quot;highlighter-rouge&quot;&gt;[2,3,-2,4]&lt;/code&gt;,
the contiguous subarray &lt;code class=&quot;highlighter-rouge&quot;&gt;[2,3]&lt;/code&gt; has the largest product = &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProduct( int[] nums ) {
    if( nums.length == 1 ) return nums[0];

    int maxPositive = 0;
    int minNegative = 0;
    int res = 0;
    for( int i = 0; i &amp;lt; nums.length; ++i ) {
        if( nums[i] &amp;gt; 0 ) {
            maxPositive = Math.max( maxPositive*nums[i], nums[i] );
            minNegative = Math.min( minNegative*nums[i], 0 );
        } else {
            int t = maxPositive;
            maxPositive = Math.max( minNegative*nums[i], 0 );
            minNegative = Math.min( t*nums[i], nums[i] );
        }
        res = Math.max( res, maxPositive );
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;. 考虑新加入一个元素对结果带来的影响? 假设新加入元素&lt;code class=&quot;highlighter-rouge&quot;&gt;nums[n]&lt;/code&gt;, 那么其结果有2种可能:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对原结果不产生影响: 还是取原有结果&lt;/li&gt;
  &lt;li&gt;对原有结果产生影响: 结果取得更大值, 而且新结果一定包含&lt;code class=&quot;highlighter-rouge&quot;&gt;num[n]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上2个可能可以看该问题具有&lt;code class=&quot;highlighter-rouge&quot;&gt;最优子结构&lt;/code&gt;特征.&lt;/p&gt;

&lt;p&gt;从上面2种可能知道, 考虑新加入元素时需要: &lt;code class=&quot;highlighter-rouge&quot;&gt;原结果&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;左边连续子数组正数最大值&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;左边连续子数组负数最小值&lt;/code&gt;(因为新结果一定包含&lt;code class=&quot;highlighter-rouge&quot;&gt;num[n]&lt;/code&gt;). 所以定义以下三个变量即可:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;res&lt;/code&gt;: 原结果&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;maxPositive&lt;/code&gt;: 左边连续子数组正数最大值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;minNegative&lt;/code&gt;: 左边连续子数组负数最小值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三个变量的状态变化情况按照当前元素&lt;code class=&quot;highlighter-rouge&quot;&gt;nums[i]&lt;/code&gt;为正负分别考虑即可.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: &lt;code class=&quot;highlighter-rouge&quot;&gt;maxPositive&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;minNegative&lt;/code&gt;等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;: 左边连续子数组无正数或无负数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;, 空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/05/leetcode-maximum-product-subarray/</link>
        <guid isPermaLink="true">/2016/04/05/leetcode-maximum-product-subarray/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Generate Parentheses</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#generate-parentheses&quot; id=&quot;markdown-toc-generate-parentheses&quot;&gt;Generate Parentheses&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generate-parentheses&quot;&gt;Generate Parentheses&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;

  &lt;p&gt;For example, given &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 3&lt;/code&gt;, a solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;((()))&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;(()())&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;(())()&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;()(())&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;()()()&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;String&amp;gt; generatePerenthesis( int n ) {
    List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helper( n, n, &quot;&quot;, res );
    return res;
}

private static void helper( int left, int right, String tmpRes, List&amp;lt;String&amp;gt; res ) {
    // 结束条件
    if( left &amp;lt; 0 ) return; 

    // 获得结果
    if( left == 0 &amp;amp;&amp;amp; right == 0 ) {
        res.add( tmpRes );
        return;
    }
    // 添加左括号
    helper( left-1, right, tmpRes+&quot;(&quot;, res );
    // 添加右括号: 右括号不能少于左括号
    if( right &amp;gt; left ) {
        helper( left, right-1, tmpRes+&quot;)&quot;, res );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义状态: &lt;code class=&quot;highlighter-rouge&quot;&gt;左括号数量, 右括号数量&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;考虑状态的解空间:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;左括号数量 &amp;lt; 0&lt;/code&gt; 表示无解&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;左括号数量 == 0 &amp;amp;&amp;amp; 右括号数量 == 0&lt;/code&gt; 表示一个解&lt;/li&gt;
      &lt;li&gt;添加左括号: 只要&lt;code class=&quot;highlighter-rouge&quot;&gt;左括号数量 &amp;gt; 0&lt;/code&gt;就可以&lt;/li&gt;
      &lt;li&gt;添加右括号: 满足条件&lt;code class=&quot;highlighter-rouge&quot;&gt;右括号数量 &amp;gt; 左括号数量&lt;/code&gt;就可以, 这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;剪枝&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;剪枝&lt;/code&gt;动作如果放在&lt;code class=&quot;highlighter-rouge&quot;&gt;求解解空间&lt;/code&gt;, 那么在&lt;code class=&quot;highlighter-rouge&quot;&gt;结束条件&lt;/code&gt;那里就只考虑正常的结束条件&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;剪枝&lt;/code&gt;动作如果放在&lt;code class=&quot;highlighter-rouge&quot;&gt;结束条件&lt;/code&gt;, 那么在&lt;code class=&quot;highlighter-rouge&quot;&gt;求解解空间&lt;/code&gt;那里就无条件进所有子解空间&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(2^n)&lt;/code&gt;, 空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/05/leetcode-generate-perentheses/</link>
        <guid isPermaLink="true">/2016/04/05/leetcode-generate-perentheses/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Hadoop 概述</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#hadoop&quot; id=&quot;markdown-toc-hadoop&quot;&gt;什么是Hadoop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hadoop-1&quot; id=&quot;markdown-toc-hadoop-1&quot;&gt;Hadoop的基本组件&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#hadoop-common&quot; id=&quot;markdown-toc-hadoop-common&quot;&gt;Hadoop Common&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hadoop-distributed-file-systemhdfs&quot; id=&quot;markdown-toc-hadoop-distributed-file-systemhdfs&quot;&gt;Hadoop Distributed File System(HDFS)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hadoop-mapreduce&quot; id=&quot;markdown-toc-hadoop-mapreduce&quot;&gt;Hadoop MapReduce&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hadoop-yarn&quot; id=&quot;markdown-toc-hadoop-yarn&quot;&gt;Hadoop YARN&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hadoop-zoo&quot; id=&quot;markdown-toc-hadoop-zoo&quot;&gt;Hadoop Zoo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hadoop-2&quot; id=&quot;markdown-toc-hadoop-2&quot;&gt;Hadoop生态系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hadoop&quot;&gt;什么是Hadoop&lt;/h3&gt;

&lt;p&gt;定义: Apache Hadoop是一个开源的软件框架, 用于产业集群上大数据集的存储与处理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hadoop一开始只是一个简单的批处理框架&lt;/li&gt;
  &lt;li&gt;Hadoop的原理是移动计算到数据, 而不是移动数据到计算&lt;/li&gt;
  &lt;li&gt;Hadoop的核心是扩展性&lt;/li&gt;
  &lt;li&gt;Hadoop必须考虑可靠性. 因为集群中的硬件软件故障事件很容易发生&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;hadoop-1&quot;&gt;Hadoop的基本组件&lt;/h3&gt;

&lt;h4 id=&quot;hadoop-common&quot;&gt;Hadoop Common&lt;/h4&gt;

&lt;p&gt;Hadoop Common提供了其他Hadoop模块需要的基本库和工具&lt;/p&gt;

&lt;h4 id=&quot;hadoop-distributed-file-systemhdfs&quot;&gt;Hadoop Distributed File System(HDFS)&lt;/h4&gt;

&lt;p&gt;HDFS是一个用Java编写的分布式文件系统&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HDFS组件: 一个NameNode, 多个DataNode&lt;/li&gt;
  &lt;li&gt;HDFS的可靠性是通过在多个主机之间拷贝数据副本实现的&lt;/li&gt;
  &lt;li&gt;Secondary NameNode的工作不是在Primary NameNode崩溃的时候替换, 而是记录Primary NameNode的某一时刻的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hadoop-mapreduce&quot;&gt;Hadoop MapReduce&lt;/h4&gt;

&lt;p&gt;MapReduce是一个编程模型, 目的是在集群上通过并行的, 分布式的算法处理大数据集&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MapReduce引擎组件: JobTracker, TaskTracker&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hadoop-yarn&quot;&gt;Hadoop YARN&lt;/h4&gt;

&lt;p&gt;Hadoop YARN是一个资源管理平台, 负责管理计算资源, 便于用户应用调度执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;YARN是下一代的MapReduce, 具有更强大的计算处理能力&lt;/li&gt;
  &lt;li&gt;YARN与MapReduce等框架相比, 具有更加广阔的交互模式&lt;/li&gt;
  &lt;li&gt;YARN与MapReduce完全兼容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hadoop-zoo&quot;&gt;Hadoop Zoo&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/hadoop/hadoop-cloudera-stack.png&quot; alt=&quot;hadoop-cloudera-stack&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hadoop-2&quot;&gt;Hadoop生态系统&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/hadoop/hadoop-ecosystem.jpg&quot; alt=&quot;hadoop-ecosystem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/hadoop/hadoop-ecosystem-describtion.png&quot; alt=&quot;hadoop-ecosystem-describtion&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/05/hadoop-overview/</link>
        <guid isPermaLink="true">/2016/04/05/hadoop-overview/</guid>
        
        
        <category>Hadoop</category>
        
      </item>
    
      <item>
        <title>Hadoop HDFS</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#hdfs&quot; id=&quot;markdown-toc-hdfs&quot;&gt;HDFS简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;设计的期望与目标&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#namenodedatanode&quot; id=&quot;markdown-toc-namenodedatanode&quot;&gt;NameNode与DataNode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;文件系统命名空间&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;数据的重复因子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#metadata&quot; id=&quot;markdown-toc-metadata&quot;&gt;metadata持久化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;通信协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;健壮性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;数据的组织&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;访问方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;空间回收&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hdfs&quot;&gt;HDFS简介&lt;/h3&gt;

&lt;p&gt;HDFS是一个分布式文件系统, 用于商业硬件平台. HDFS跟其他分布式文件系统有很多共性, 但是不同的是HDFS有以下重要特性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高容错性&lt;/li&gt;
  &lt;li&gt;可部署于低端硬件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HDFS提供了&lt;strong&gt;高吞吐量的数据访问方式&lt;/strong&gt;, 而且非常适合具有&lt;strong&gt;大数据集&lt;/strong&gt;的应用使用.&lt;/p&gt;

&lt;p&gt;HDFS放宽了POSIX的规范要求, 目的是为了&lt;strong&gt;数据的流式访问&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;HDFS一开始是为了Nutch Web搜索引擎项目而创建的, 现在是Apache Hadoop的核心项目&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;设计的期望与目标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;硬件故障 : HDFS是应用于集群的, 所以硬件故障的发生概率是很高的, 设计时是必须提前考虑&lt;/li&gt;
  &lt;li&gt;数据流式访问 : 流式访问可以提高数据传输的吞吐量&lt;/li&gt;
  &lt;li&gt;大数据集 : 基于HDFS的应用一般都是拥有大数据集的, 否则分布式没有意义&lt;/li&gt;
  &lt;li&gt;简单的一致性模型 : HDFS期望应用对数据的使用情况是写一次, 读多次的, 而且对数据的修改不是立刻发生的, 这样有利于提高吞吐量&lt;/li&gt;
  &lt;li&gt;移动计算到数据 : 基于大数据集的情况, 移动数据很耗性能, 所以要支持移动计算到数据&lt;/li&gt;
  &lt;li&gt;可移植性 : 可移植性提高了HDFS的使用范围&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;namenodedatanode&quot;&gt;NameNode与DataNode&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;NameNode : 管理文件系统命名空间, 管理文件访问操作&lt;/li&gt;
  &lt;li&gt;DataNode : 保存数据&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HDFS架构模型&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/hadoop/hadoop-hdfs-architecture.png&quot; alt=&quot;hadoop-hdfs-architecture&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;文件系统命名空间&lt;/h3&gt;

&lt;p&gt;HDFS的命名空间支持传统的文件组织结构(也就是树形层次结构)&lt;/p&gt;

&lt;p&gt;HDFS的命名空间是由NameNode管理的&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;数据的重复因子&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;副本放置 : 理想条件下, 我们会把副本放在相互远离的地方; 但是考虑到性能问题, 一般情况下把2个副本放在同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;rack&lt;/code&gt;, 1个副本放在另一个&lt;code class=&quot;highlighter-rouge&quot;&gt;rack&lt;/code&gt;(假设重复因子为3)&lt;/li&gt;
  &lt;li&gt;副本读取 : 从性能角度出发, HDFS会优先选择离Client最近的副本为Client提供服务&lt;/li&gt;
  &lt;li&gt;Safemode模式 : 该模式是NameNode刚开启时的模式, 这个模式下的NameNode会接受Heartbeat和Blockreport, 收集完Blockreport之后就会退出该模式. 退出该模式之后如果发现有数据块的重复因子小于设定的下限, 那么NameNode就负责复制数据块直到满足条件为止.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;safemode模式下是没有副本相关信息的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;metadata&quot;&gt;metadata持久化&lt;/h3&gt;

&lt;p&gt;HDFS的metadata持久化通过2种文件(都是本地保存)来实现:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FsImage : 保存了数据块的映射信息, 文件系统的属性&lt;/li&gt;
  &lt;li&gt;EditLog : 事务日志, 记录了所有的HDFS操作记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;checkpoint机制: 当NameNode启动的时候, 首先读取FsImage和EditLog进内存, 然后根据EditLog修改FsImage, 再把FsImage更新到磁盘上, 最后对EditLog进行缩减&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;checkpoint机制只有在NameNode启动时才会触发(目前)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;通信协议&lt;/h3&gt;

&lt;p&gt;HDFS的通信协议都是基于TCP/IP协议的. 主要有2种协议:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClientProtocol : 用于Client和NameNode之间的通信&lt;/li&gt;
  &lt;li&gt;DataNodeProtocol : 用于DataNode和NameNode之间的通信&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这2种协议都通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;进行了抽象封装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;健壮性&lt;/h3&gt;

&lt;p&gt;健壮性是HDFS的一个重要特性. HDFS为了健壮性作出了下面这些保证:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重新复制副本 : NameNode会时常检查各个数据块的重复因子, 保证重复因子达到预设状态&lt;/li&gt;
  &lt;li&gt;集群负载重平衡 : HDFS兼通数据重平衡方案&lt;/li&gt;
  &lt;li&gt;数据完整性 : Client端通过DataNode获取文件之后会通过checksum检查数据的完整性&lt;/li&gt;
  &lt;li&gt;metadata失效恢复 : NameNode保留了多份FsImage和EditLog以便恢复数据&lt;/li&gt;
  &lt;li&gt;数据快照 : 数据快照就是某一时刻数据的副本, 可用于回滚操作&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;重复因子变化的原因多种多样 : DataNode无效, 副本失效, 硬盘故障, 重复因子变大&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;数据的组织&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;数据块 : 基于HDFS的应用一般都是拥有大数据集的, 并且通常对数据的操作是写一次, 读多次的. 所以为了提高数据传输的吞吐量, 数据以数据块的方式保留, 而且以流式方式传输.&lt;/li&gt;
  &lt;li&gt;分段运输 : Client如果要写入数据到DataNode. Client首先会把数据写入自己的缓冲区中, 如果缓冲区的数据达到数据块的大小, 那么Client就会向NameNode发送写入数据的请求, NameNode进行metadata的修改之后返回DataNode的id, 让Client与对应的DataNode连接并传输数据. 数据传输完成后Client通知NameNode关闭文件, 最后NameNode进行事务日志的写入, 到此操作完成. 如果日志写入失败, 那么此次操作也是失效的.&lt;/li&gt;
  &lt;li&gt;副本管道流 : 因为副本的原因, Client在写入数据到DataNode的时候是要写入很多份的, HDFS的处理机制则是以副本管道流的形式. Client每传输一部分数据, 第一个DataNode就会写入数据并把数据传递给第二个DataNode, 第二个DataNode也是和第一个DataNode一样, 如此推进就形成了管道流.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;HDFS的数据块大小一般是64MB, 而且NameNode尽量把数据块放在不同的DataNode&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-6&quot;&gt;访问方式&lt;/h3&gt;

&lt;p&gt;HDFS的访问方式有以下3种:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FS Shell : 类似于bash的命令行方式&lt;/li&gt;
  &lt;li&gt;DFSAdmin : 给HDFS的administrator使用的命令行方式&lt;/li&gt;
  &lt;li&gt;Browser Interface : 借助浏览器的http协议进行访问&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-7&quot;&gt;空间回收&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;文件删除 : Client在删除文件的命令发出后, HDFS的释放空间动作并没有同步执行, 具有一定的时间差. 被删除的文件会保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;/user/&amp;lt;username&amp;gt;/.Trash&lt;/code&gt;目录中. 在这段时间差内, 数据是可恢复的. 真正释放空间的时机是由checkpoint决定的.&lt;/li&gt;
  &lt;li&gt;副本因子降低 : 如果数据块的副本因子变小了, 那么NameNode就会发送心跳包给对应的DataNode, 告诉它把副本删除. 同样, 删除过程也是会有时间差.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;默认情况下Trash机制是关闭的, 需要配置才能开启&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/05/hadoop-HDFS/</link>
        <guid isPermaLink="true">/2016/04/05/hadoop-HDFS/</guid>
        
        
        <category>Hadoop</category>
        
      </item>
    
      <item>
        <title>系统资源的查看</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#free-&quot; id=&quot;markdown-toc-free-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;: 查看内存使用情况&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#free&quot; id=&quot;markdown-toc-free&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#free-1&quot; id=&quot;markdown-toc-free-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#uname-&quot; id=&quot;markdown-toc-uname-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;: 查看系统内核相关信息&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#uname&quot; id=&quot;markdown-toc-uname&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#uname-1&quot; id=&quot;markdown-toc-uname-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#uptime-&quot; id=&quot;markdown-toc-uptime-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt;: 查看系统启动时间与工作负载&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#uptime&quot; id=&quot;markdown-toc-uptime&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt;参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#uptime-1&quot; id=&quot;markdown-toc-uptime-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt;使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#netstat-&quot; id=&quot;markdown-toc-netstat-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;: 查看跟踪网络&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#netstat&quot; id=&quot;markdown-toc-netstat&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#netstat-1&quot; id=&quot;markdown-toc-netstat-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dmesg-&quot; id=&quot;markdown-toc-dmesg-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;: 查看内核产生的信息&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dmesg&quot; id=&quot;markdown-toc-dmesg&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vmstat-&quot; id=&quot;markdown-toc-vmstat-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;: 检测系统资源变化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vmstat&quot; id=&quot;markdown-toc-vmstat&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vmstat-1&quot; id=&quot;markdown-toc-vmstat-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;free-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;: 查看内存使用情况&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;free [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;free&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-k&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;KB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;GB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示总量统计&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;free-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;显示目前系统的内存容量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;free -m -t
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-free-m-t.png&quot; alt=&quot;linux-free-m-t&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;系统中内存的使用量非常高, 而且&lt;code class=&quot;highlighter-rouge&quot;&gt;buffers&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cached&lt;/code&gt;也非常大, 这是linux善于利用内存的表现, 它把&lt;code class=&quot;highlighter-rouge&quot;&gt;最常使用到的数据&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;最近使用到的数据&lt;/code&gt;都缓存下来了, 下次访问就直接从内存读取, 而不需要再去访问磁盘, 提高了访问速度.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;uname-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;: 查看系统内核相关信息&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 默认是 uname -s
uname [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;uname&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有系统内核信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;系统内核名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;内核版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;硬件名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;CPU类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;硬件平台&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;uname-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uname&lt;/code&gt;使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;显示系统内核所有信息&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uname -a
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-uname-a.png&quot; alt=&quot;linux-uname-a&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;uptime-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt;: 查看系统启动时间与工作负载&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uptime [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;uptime&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt;参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;以完整形式显示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;yyyy-mm-dd HH:MM:SS&lt;/code&gt;开始统计&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;uptime-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt;使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;显示系统启动时间与工作负载&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uptime
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-uptime.png&quot; alt=&quot;linux-uptime&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;工作负载分别表示: 1分钟内 / 5分钟内 / 15分钟内 的平均工作负载&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;netstat-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;: 查看跟踪网络&lt;/h3&gt;

&lt;h4 id=&quot;netstat&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示系统所有连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;列出tcp网络数据包的数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;列出udp网络数据包的数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;以端口号替换服务名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示正在网络监听的服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示服务PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;netstat-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt;使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;显示所有打开的网络连接与&lt;code class=&quot;highlighter-rouge&quot;&gt;unix socket&lt;/code&gt;状态&lt;/p&gt;

    &lt;p&gt;netstat -a&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-netstat-a.png&quot; alt=&quot;linux-netstat-a&quot; /&gt;
  &lt;img src=&quot;/assets/linux/linux-netstat-a2.png&quot; alt=&quot;linux-netstat-a2&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;dmesg-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;: 查看内核产生的信息&lt;/h3&gt;

&lt;h4 id=&quot;dmesg&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;输出所有内核开机时的信息&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dmesg | more
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-dmesg.png&quot; alt=&quot;linux-dmesg&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查找开机时硬盘相关的信息&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dmesg | grep -i hd
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-dmesg-grep-sd.png&quot; alt=&quot;linux-dmesg-grep-sd&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;vmstat-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;: 检测系统资源变化&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vmstat [options] [delay [count]]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delay&lt;/code&gt;: 更新延迟&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;: 更新次数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;vmstat&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示活跃与非活跃状态的内存量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示系统启动至今的fork数量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示事件导致的内存变化列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-S&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;统计单位k/m(10进制), K/M(2进制)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;列出磁盘读写总量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;分区磁盘读写总量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;vmstat-1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmstat&lt;/code&gt;使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;显示系统资源状态, 更新频率1秒, 更新次数3次&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vmstat 1 3
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-vmstat-1-3.png&quot; alt=&quot;linux-vmstat-1-3&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;参数说明:&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;等待运行的进程数量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;阻塞的进程数量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swpd&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;虚拟内存使用总量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;空闲内存总量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buff&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;缓冲内存总量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;缓存内存重量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;si&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;磁盘换进内存的总量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;内存换出磁盘的总量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bi&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;从磁盘读取的块数量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bo&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;写入到磁盘的块数量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;每秒的中断数量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cs&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;每秒的上下文切换数量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;us&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;非内核状态CPU使用百分比&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sy&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;内核状态CPU使用百分比&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;闲置状态CPU使用百分比&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wa&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;IO等待CPU使用百分比&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;st&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;虚拟机占用CPU使用百分比&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;有关参数详细说明可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;man vmstat&lt;/code&gt;查询&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/04/linux-system-resources-check/</link>
        <guid isPermaLink="true">/2016/04/04/linux-system-resources-check/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>进程的管理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;信号表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#kill&quot; id=&quot;markdown-toc-kill&quot;&gt;kill指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#kill-1&quot; id=&quot;markdown-toc-kill-1&quot;&gt;kill参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#kill-2&quot; id=&quot;markdown-toc-kill-2&quot;&gt;kill使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#killall&quot; id=&quot;markdown-toc-killall&quot;&gt;killall指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#killall-1&quot; id=&quot;markdown-toc-killall-1&quot;&gt;killall参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#killall-2&quot; id=&quot;markdown-toc-killall-2&quot;&gt;killall使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程的管理是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;信号机制&lt;/code&gt;来实现的. 把一个信号传递给进程, 进程就会做出相应的动作, 这就是进程管理&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;信号表&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;代号&lt;/th&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGHUP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;启动终止的进程, 如果已经启动则重新读取配置, 相当于重启&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGINT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;中断一个进程的执行, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+c&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;强制中断一个进程的执行, 但是会产生历史缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTERM&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;正常结束一个进程的执行, 如果进程已经异常, 那么信号无效&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;暂停一个进程的执行, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+z&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上信号表是常用的信号说明, 更加详细的可以通过指令: &lt;code class=&quot;highlighter-rouge&quot;&gt;kill -l&lt;/code&gt;查询&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;kill&quot;&gt;kill指令&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;指令从名字上看就是杀死进程的样子, 实际上不是. &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;指令是用于传送指定的信号给指定的进程.&lt;/p&gt;

&lt;h4 id=&quot;kill-1&quot;&gt;kill参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;列出所有的信号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;表格形式列出所有的信号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;lt;signal&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;指定信号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;kill-2&quot;&gt;kill使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;启动或重启syslog进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -SIGHUP $(ps aux|grep &#39;syslog&#39;|grep -v &#39;grep&#39;|awk &#39;{print $2}&#39;)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;终止所有可以终止的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -9 -1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;killall&quot;&gt;killall指令&lt;/h3&gt;

&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;指令的时候发现每次都需要指定&lt;code class=&quot;highlighter-rouge&quot;&gt;PID&lt;/code&gt;, 这样非常麻烦. &lt;code class=&quot;highlighter-rouge&quot;&gt;killall&lt;/code&gt;指令帮助我们解决了问题, 它通过指定命令名称来发送信号.&lt;/p&gt;

&lt;h4 id=&quot;killall-1&quot;&gt;killall参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;交互式执行&lt;code class=&quot;highlighter-rouge&quot;&gt;killall&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;命令名称忽略大小写&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;指定命令名称要完全一致, 但是最多15个字符, 超过15以15个匹配&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;killall-2&quot;&gt;killall使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;启动或重启以&lt;code class=&quot;highlighter-rouge&quot;&gt;syslogd&lt;/code&gt;命令启动的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;killall -1 syslogd
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;终止所有以&lt;code class=&quot;highlighter-rouge&quot;&gt;httpd&lt;/code&gt;命令启动的进程, 并且交互式进行&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;killall -i -9 httpd
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/04/linux-process-management/</link>
        <guid isPermaLink="true">/2016/04/04/linux-process-management/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Ugly Number(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ugly-number&quot; id=&quot;markdown-toc-ugly-number&quot;&gt;Ugly Number&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ugly-number-ii&quot; id=&quot;markdown-toc-ugly-number-ii&quot;&gt;Ugly Number II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ugly-number&quot;&gt;Ugly Number&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;

  &lt;p&gt;Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.&lt;/p&gt;

  &lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static boolean isUgly( int num ) {
    if( num == 0 ) return false;
    while( num % 2 == 0 )
        num /= 2;
    while( num % 3 == 0 )
        num /= 3;
    while( num % 5 == 0 )
        num /= 5;
    return num == 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;数学问题&lt;/code&gt;. 一个数字&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;Ugly Number&lt;/code&gt;, 那么这个&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;就一定能够被&lt;code class=&quot;highlighter-rouge&quot;&gt;2,3,5&lt;/code&gt;整除, 所以只要一路整除下来, 最后判断结果就行了&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(logn): n表示树的所有节点数, 空间复杂度是O(1)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ugly-number-ii&quot;&gt;Ugly Number II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Write a program to find the n-th ugly number.&lt;/p&gt;

  &lt;p&gt;Ugly numbers are positive numbers whose prime factors only include &lt;code class=&quot;highlighter-rouge&quot;&gt;2, 3, 5&lt;/code&gt;. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;1, 2, 3, 4, 5, 6, 8, 9, 10, 12&lt;/code&gt; is the sequence of the first &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt; ugly numbers.&lt;/p&gt;

  &lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int nthUglyNumber( int n ) {

    int[] nums = new int[n];
    int index = 1;
    nums[0] = 1; 

    int count2 = 0, count3 = 0, count5 = 0;

    while( index &amp;lt; n ) {
        int num = Math.min(nums[count5]*5,
                Math.min(nums[count2]*2, nums[count3]*3));
        nums[index++] = num;
        if( num % 2 == 0 ) count2++;
        if( num % 3 == 0 ) count3++;
        if( num % 5  == 0 ) count5++;
    }
    return nums[n-1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Ugly Number&lt;/code&gt;只能被&lt;code class=&quot;highlighter-rouge&quot;&gt;2,3,5&lt;/code&gt;整除, 而且我们需要找出第&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;Ugly Number&lt;/code&gt;, 那么我们就可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;2,3,5&lt;/code&gt;来动态构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Ugly Number&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;count2, count3, count5&lt;/code&gt;分别表示&lt;code class=&quot;highlighter-rouge&quot;&gt;2,3,5使用的次数&lt;/code&gt;. 每次构造&lt;code class=&quot;highlighter-rouge&quot;&gt;一个最小值&lt;/code&gt;并且加入数组中(数组是排序的&lt;code class=&quot;highlighter-rouge&quot;&gt;Ugly Number&lt;/code&gt;), 然后把用到的因数分别&lt;code class=&quot;highlighter-rouge&quot;&gt;+1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(n)&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/04/leetcode-ugly-number(II)/</link>
        <guid isPermaLink="true">/2016/04/04/leetcode-ugly-number(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Path Sum</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#path-sum&quot; id=&quot;markdown-toc-path-sum&quot;&gt;Path Sum&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#path-sum-ii&quot; id=&quot;markdown-toc-path-sum-ii&quot;&gt;Path Sum II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;path-sum&quot;&gt;Path Sum&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;/p&gt;

  &lt;p&gt;For example:&lt;/p&gt;

  &lt;p&gt;Given the below binary tree and sum = 22,&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           5
          / \
         4   8
        /   / \
       11  13  4
      /  \      \
     7    2      1
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;p&gt;return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static boolean hasPathSum( TreeNode root, int sum ) {
    if( root == null ) return false;
    if( root.val == sum &amp;amp;&amp;amp; 
            root.left == null &amp;amp;&amp;amp; 
            root.right == null ) return true;
    return hasPathSum( root.left, sum-root.val ) || 
            hasPathSum( root.right, sum-root.val);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;DFS&lt;/code&gt;. &lt;strong&gt;有关树的问题一般都是以递归的思想解决的, 因为树的定义本身就是递归的.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n): n表示树的所有节点数, 空间复杂度是O(h): h表示树的高度&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;path-sum-ii&quot;&gt;Path Sum II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.&lt;/p&gt;

  &lt;p&gt;For example:
Given the below binary tree and sum = 22,&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           5
          / \
         4   8
        /   / \
       11  13  4
      /  \    / \
     7    2  5   1
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;p&gt;return&lt;/p&gt;

  &lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; PathSum( TreeNode root, int sum ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperPathSum( root, sum, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperPathSum( TreeNode root, int sum,
        List&amp;lt;Integer&amp;gt; tmpRes, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res ) {
    if( root == null ) return;

    if( sum == root.val &amp;amp;&amp;amp; root.left == null &amp;amp;&amp;amp; root.right == null ) {
        tmpRes.add( root.val );
        res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
        tmpRes.remove( tmpRes.size()-1 );
        return;
    }

    tmpRes.add( root.val );
    helperPathSum( root.left, sum-root.val, tmpRes, res );
    helperPathSum( root.right, sum-root.val, tmpRes, res );
    tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;DFS&lt;/code&gt;. 相比于&lt;code class=&quot;highlighter-rouge&quot;&gt;Path Sum&lt;/code&gt;, 区别就是要记录所有的路径, 那么只需要多添加一些参数就可以了: &lt;code class=&quot;highlighter-rouge&quot;&gt;tmpRes&lt;/code&gt;用于记录当前路径, &lt;code class=&quot;highlighter-rouge&quot;&gt;res&lt;/code&gt;表示结果路径集.&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n): n表示树的所有节点数, 空间复杂度是O(h): h表示树的高度&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;本题提醒了我: 在包含有递归的算法中, 一定要保证进入递归前的条件状态一致. 例如在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;helperPathSum&lt;/code&gt;的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;的值是未选取的, 那么递归里面就需要去选取处理, 并且保证进入下一轮递归之前条件状态一致.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/04/leetcode-path-sum(II)/</link>
        <guid isPermaLink="true">/2016/04/04/leetcode-path-sum(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Maximum Subarray</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#maximum-subarray&quot; id=&quot;markdown-toc-maximum-subarray&quot;&gt;Maximum Subarray&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;maximum-subarray&quot;&gt;Maximum Subarray&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

  &lt;p&gt;For example, given the array &lt;code class=&quot;highlighter-rouge&quot;&gt;[−2,1,−3,4,−1,2,1,−5,4]&lt;/code&gt;,
the contiguous subarray &lt;code class=&quot;highlighter-rouge&quot;&gt;[4,−1,2,1]&lt;/code&gt; has the largest &lt;code class=&quot;highlighter-rouge&quot;&gt;sum = 6&lt;/code&gt;.&lt;/p&gt;

  &lt;p&gt;More practice:&lt;/p&gt;

  &lt;p&gt;If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分治法&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxSubArrayDivideAndConquer( int[] nums ) {
      return helper( nums, 0, nums.length-1 );
  }
  private static int helper( int[] nums, int left, int right ) {
      if( left &amp;gt;= right ) return nums[left];

      int mid = left + (right-left)/2;
      int leftMax = helper( nums, left, mid-1 );
      int rightMax = helper( nums, mid+1, right );

      // midLeftMax: mid左边连续部分最大值
      // midRightMax: mid右边连续部分最大值
      int t = 0, midLeftMax = 0, midRightMax = 0;

      for( int i = mid-1; i &amp;gt;= left; --i ) {
          t += nums[i];
          if( t &amp;gt; midLeftMax ) midLeftMax = t;
      }
      t = 0;
      for( int i = mid+1; i &amp;lt;= right; ++i ) {
          t += nums[i];
          if( t &amp;gt; midRightMax ) midRightMax = t;
      }

      int midMax = midLeftMax + nums[mid] + midRightMax;
      return Math.max( Math.max( leftMax, rightMax ), midMax );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;分治法&lt;/code&gt;. 求某一个范围的&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;, 从范围中间切成2部分, 其结果有三种可能&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;在左半部分的&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;在右半部分的&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;中间元素&lt;/code&gt;联合&lt;code class=&quot;highlighter-rouge&quot;&gt;左右半部分&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Max Subarray&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(nlogn)&lt;/code&gt;, 空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxSubArray( int[] nums ) {
      if( nums.length == 1 ) return nums[0];

      int max = nums[0], preSum = nums[0];
      for( int i = 1; i &amp;lt; nums.length; ++i ) {
          preSum = Math.max( preSum+nums[i], nums[i] );
          max = Math.max( max, preSum );
      }
      return max;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;. 考虑新加入一个元素对结果带来的影响? 假设新加入元素&lt;code class=&quot;highlighter-rouge&quot;&gt;num[n]&lt;/code&gt;, 那么其结果有2种可能:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;对原结果不产生影响: 还是取原有结果&lt;/li&gt;
      &lt;li&gt;对原有结果产生影响: 结果取得更大值, 而且新结果一定包含&lt;code class=&quot;highlighter-rouge&quot;&gt;num[n]&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;以上2个可能可以看该问题具有&lt;code class=&quot;highlighter-rouge&quot;&gt;最优子结构&lt;/code&gt;特征.&lt;/p&gt;

    &lt;p&gt;从上面2种可能知道, 考虑新加入元素时需要: &lt;code class=&quot;highlighter-rouge&quot;&gt;原结果&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;左边连续子数组最大值&lt;/code&gt;(因为新结果一定包含&lt;code class=&quot;highlighter-rouge&quot;&gt;num[n]&lt;/code&gt;). 所以定义以下两个变量即可:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max&lt;/code&gt;: 原结果&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;preSum&lt;/code&gt;: 左边连续子数组最大值&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;接下来考虑这两个变量的变化:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;下一个preSum&lt;/code&gt;: 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;preSum&lt;/code&gt;是连续的, 那么一定有&lt;code class=&quot;highlighter-rouge&quot;&gt;num[i]&lt;/code&gt;, 如果加上&lt;code class=&quot;highlighter-rouge&quot;&gt;preSum&lt;/code&gt;可以取得更大值, 那么就取&lt;code class=&quot;highlighter-rouge&quot;&gt;preSum&lt;/code&gt;, 否则不取&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;下一个max&lt;/code&gt;: 保留&lt;code class=&quot;highlighter-rouge&quot;&gt;原结果&lt;/code&gt;或更换为&lt;code class=&quot;highlighter-rouge&quot;&gt;新结果preSum&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;, 空间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/04/leetcode-maximum-subarray/</link>
        <guid isPermaLink="true">/2016/04/04/leetcode-maximum-subarray/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Minimum Path Sum</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#minimum-path-sum&quot; id=&quot;markdown-toc-minimum-path-sum&quot;&gt;Minimum Path Sum&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;minimum-path-sum&quot;&gt;Minimum Path Sum&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.&lt;/p&gt;

  &lt;p&gt;Note: You can only move either down or right at any point in time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int minPathSum( int[][] grid ) {

    int m = grid.length, n = grid[0].length;
    int[][] dp = new int[m][n];
    dp[0][0] = grid[0][0];
    for( int i = 1; i &amp;lt; m; ++i )
        dp[i][0] = grid[i][0]+dp[i-1][0];

    for( int j = 1; j &amp;lt; n; ++j )
        dp[0][j] = grid[0][j]+dp[0][j-1];

    for( int i = 1; i &amp;lt; m; ++i )
        for( int j = 1; j &amp;lt; n; ++j )
            dp[i][j] = Math.min( dp[i-1][j], dp[i][j-1] ) + grid[i][j];

    return dp[m-1][n-1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;当前格子&lt;/code&gt;的最小值是由&lt;code class=&quot;highlighter-rouge&quot;&gt;左边一格&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;上边一格&lt;/code&gt;加上当前的值组成的. 也就是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;: 在第&lt;code class=&quot;highlighter-rouge&quot;&gt;[i][j]&lt;/code&gt;个格子的最小值&lt;/li&gt;
  &lt;li&gt;最优子结构: &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j] = Math.min( dp[i-1][j], dp[i][j-1] ) + grid[i][j]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;重复子问题: &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j-1]&lt;/code&gt;中有共同的子问题&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n^2), 空间复杂度是O(n^2)&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/04/leetcode-letter-minimum-path-sum/</link>
        <guid isPermaLink="true">/2016/04/04/leetcode-letter-minimum-path-sum/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
  </channel>
</rss>
