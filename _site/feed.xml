<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SCH</title>
    <description>苏灿灏的博客 大数据爱好者</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 01 Apr 2016 20:20:48 +0800</pubDate>
    <lastBuildDate>Fri, 01 Apr 2016 20:20:48 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>JUnit</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#junit&quot; id=&quot;markdown-toc-junit&quot;&gt;JUnit简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junit-1&quot; id=&quot;markdown-toc-junit-1&quot;&gt;JUnit的原理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-2&quot; id=&quot;markdown-toc-junit-2&quot;&gt;JUnit结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-3&quot; id=&quot;markdown-toc-junit-3&quot;&gt;JUnit核心类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-4&quot; id=&quot;markdown-toc-junit-4&quot;&gt;JUnit生命周期&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#junit-5&quot; id=&quot;markdown-toc-junit-5&quot;&gt;JUnit中的设计模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;junit&quot;&gt;JUnit简介&lt;/h3&gt;

&lt;p&gt;JUnit就是为Java程序开发者实现单元测试提供一种框架，使得Java单元测试更规范有效，并且更有利于测试的集成&lt;/p&gt;

&lt;h3 id=&quot;junit-1&quot;&gt;JUnit的原理&lt;/h3&gt;

&lt;h4 id=&quot;junit-2&quot;&gt;JUnit结构&lt;/h4&gt;

&lt;p&gt;JUnit中有7个包, 每个包的简要说明如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;包名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.awtui&lt;/td&gt;
      &lt;td&gt;以awt界面组件来显示junit测试过程结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.swingui&lt;/td&gt;
      &lt;td&gt;以swing界面组件来显示junit测试过程结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.textui&lt;/td&gt;
      &lt;td&gt;以控制台输出来显示junit测试过程结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.framework&lt;/td&gt;
      &lt;td&gt;junit的核心功能包, 包括Test/TestCase/TestSuite/TestResult/TestListener等类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.runner&lt;/td&gt;
      &lt;td&gt;junit核心功能包, 主要运行Test类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;junit.extensions&lt;/td&gt;
      &lt;td&gt;junit扩展功能包&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;junit-3&quot;&gt;JUnit核心类&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/software-testing/junit-main-class.jpg&quot; alt=&quot;junit-main-class&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类名&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Test&lt;/td&gt;
      &lt;td&gt;用于运行测试和收集测试结果, 还可以获取测试用例个数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestCase&lt;/td&gt;
      &lt;td&gt;Test接口的一个实现类, 给出了测试的基本实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestSuite&lt;/td&gt;
      &lt;td&gt;Test接口的另一个实现类, 可以包含多个TestCase&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestResult&lt;/td&gt;
      &lt;td&gt;包含收集到的测试结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TestListener&lt;/td&gt;
      &lt;td&gt;测试流程的监听接口, 可以开始/结束测试, 可以添加failures/errors&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;junit-4&quot;&gt;JUnit生命周期&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/software-testing/junit-life.png&quot; alt=&quot;junit-life&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;junit-5&quot;&gt;JUnit中的设计模式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Template Method&lt;/p&gt;

    &lt;p&gt;实质就是首先建立方法的骨架，而尽可能地将方法的具体实现向后推移.&lt;/p&gt;

    &lt;p&gt;TestCase.runBare()就采用了这种模式，客户类均可以重载它的三个方法，这样使得测试的可伸缩性得到提高.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public void runBare() throws Throwable{ 
      setUp(); 
      try {
          runTest();
      } finally {
          tearDown();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Command&lt;/p&gt;

    &lt;p&gt;实质就是将动作封装为一个对象，而不关心动作的接收者。这样动作的接收者可以一直到动作具体执行时才需确定.&lt;/p&gt;

    &lt;p&gt;接口Test就是一个Command集，使得不同类的不同测试方法可以通过同一种接口Test构造其框架结构。这样对测试的集成带来了很多方便.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/01/software-testing-junit/</link>
        <guid isPermaLink="true">/2016/04/01/software-testing-junit/</guid>
        
        
        <category>软件测试</category>
        
      </item>
    
      <item>
        <title>BestTimeToBuyAndSellStock(II)(III)(IV)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock&quot; id=&quot;markdown-toc-besttimetobuyandsellstock&quot;&gt;BestTimeToBuyAndSellStock&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock-ii&quot; id=&quot;markdown-toc-besttimetobuyandsellstock-ii&quot;&gt;BestTimeToBuyAndSellStock II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock-iv&quot; id=&quot;markdown-toc-besttimetobuyandsellstock-iv&quot;&gt;BestTimeToBuyAndSellStock IV&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#besttimetobuyandsellstock-iii&quot; id=&quot;markdown-toc-besttimetobuyandsellstock-iii&quot;&gt;BestTimeToBuyAndSellStock III&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock&quot;&gt;BestTimeToBuyAndSellStock&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;暴力法&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxProfitBruteForce( int[] prices ) {
      int maxProfit = 0;
      for( int i = 0; i &amp;lt; prices.length-1; ++i ) {
          for( int j = i+1; j &amp;lt; prices.length; ++j ) {
              if( prices[j] - prices[i] &amp;gt; maxProfit )
                  maxProfit = prices[j] - prices[i];
          }
      }
      return maxProfit;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 对于每一天, 我们都计算出这一天卖出可以获得的maxProfit&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(n^2), 空间复杂度是O(1)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分治法&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxProfitDivideAndConquer( 
          int[] prices, int left, int right ) {
      if( left &amp;gt;= right ) return 0;
      int mid = left + (right-left)/2;
      int leftMaxProfit = maxProfitDivideAndConquer( prices, left, mid );
      int rightMaxProfit = maxProfitDivideAndConquer( prices, mid+1, right );
      // 求出左半部分最低价
      int leftMin = mid;
      for( int i = mid; i &amp;gt;= left; --i )
          if( prices[i] &amp;lt; prices[leftMin] )
              leftMin = i;

      // 求出右半部分最高价
      int rightMax = mid;
      for( int i = mid; i &amp;lt;= right; ++i )
          if( prices[i] &amp;gt; prices[rightMax] )
              rightMax = i;

      return Math.max( 
              Math.max( leftMaxProfit, rightMaxProfit ), 
              prices[rightMax]-prices[leftMin] );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 对于给定的一段时间&lt;code class=&quot;highlighter-rouge&quot;&gt;[left...right]&lt;/code&gt;, 我们从中间mid把时间段切割为&lt;code class=&quot;highlighter-rouge&quot;&gt;[left...mid]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;[mid+1...right]&lt;/code&gt;, 那么在&lt;code class=&quot;highlighter-rouge&quot;&gt;[left...right]&lt;/code&gt;这段时间的解为以下的情况之一:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;[left…mid] 的maxProfit&lt;/li&gt;
      &lt;li&gt;[mid+1…right] 的maxProfit&lt;/li&gt;
      &lt;li&gt;右半部分最高价 - 左半部分最低价&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(nlogn), 空间复杂度是O(logn)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static int maxProfitDP( int[] prices ) {
      int leftMin = 0, maxProfit = 0;
      for( int i = 1; i &amp;lt; prices.length; ++i ) {
          if( prices[i] - prices[leftMin] &amp;gt; maxProfit )
              maxProfit = prices[i] - prices[leftMin];
          if( prices[i] &amp;lt; prices[leftMin] )
              leftMin = i;
      }
      return maxProfit;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 由前面的暴力法可知, 我们对每一天都求出这一天卖出的maxProfit, 而这个maxProfit实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;当天价格-历史价格最低价&lt;/code&gt;. 暴力法中我们遍历查询历史价格, 其实我们可以用一个变量来记录历史价格最低价, 也就是代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;leftMin&lt;/code&gt;. 这样可以把查询时间从O(n)降到O(1).&lt;/p&gt;

    &lt;p&gt;这种解法看似与DP没什么关系, 只是在原来的基础上做出了优化而已, 其实这个优化就是动态规划的思想了. 其体现如下:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;最优子结构: maxProfit[i] = max( maxProrit[i-1], prices[i]-prices[leftMin] )&lt;/li&gt;
      &lt;li&gt;重叠子问题: leftMin的查找&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock-ii&quot;&gt;BestTimeToBuyAndSellStock II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProfit( int[] prices ) {
    // S表示前一次卖的日期, B表示前一次买的日期
    int S = 0, B = 0, maxProfit = 0;
    for( int i = 1; i &amp;lt; prices.length; ++i ) {
        if( B &amp;gt;= S ) {        // 最近一次交易是买
            if( prices[i] &amp;lt; prices[B] ) {
                B = i;
            } else if( prices[i] &amp;gt; prices[B] ) {
                maxProfit += prices[i] - prices[B];
                S = i;
            } 
        } else {            // 最近一次交易是卖
            if( prices[i] &amp;gt; prices[S] ) {
                maxProfit += prices[i] - prices[S];
                S = i;
            } else if( prices[i] &amp;lt; prices[S] ) {
                B = i;
            }
        }
    }
    return maxProfit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 因为交易次数无限, 所以只要赚钱就卖出去, 低价就买回来 – &lt;code class=&quot;highlighter-rouge&quot;&gt;贪心算法&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们使用两个变量: &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;表示前一次卖出的日期, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;表示前一次买进的日期. 对于每一天, 先判断最近一次交易是买还是卖.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最近一次交易是买, 如果今天价格更低就当作今天才买进, 如果今天价格更高就卖出去.&lt;/li&gt;
  &lt;li&gt;最近一次交易是卖, 如果今天价格更高就当作今天才卖出, 如果今天价格更低就买进来.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock-iv&quot;&gt;BestTimeToBuyAndSellStock IV&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most k transactions.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProfitDP( int k, int[] prices ) {
    int len = prices.length;

    // 如果交易次数超过最大交易次数, 获取最大利润
    if( k &amp;gt; len/2 ) return quickSolve( prices );

    // dp[i][j]: 在第j天之前交易i次可以获得的最大利润
    int[][] dp = new int[k+1][len];
    for( int i = 1; i &amp;lt;= k; ++i ) {
        // holds: 买进状态下, 目前持有的最大利润
        int holds = -prices[0];
        for( int j = 1; j &amp;lt; len; ++j ) {
            dp[i][j] = Math.max( dp[i][j-1], holds+prices[j] );
            holds = Math.max( holds, dp[i-1][j-1]-prices[j] );
        }
    }
    return dp[k][len-1];
}

private static int quickSolve( int[] prices ) {
    int profit = 0;
    for( int i = 1; i &amp;lt; prices.length; ++i )
        if( prices[i] &amp;gt; prices[i-1] )
            profit += prices[i] - prices[i-1];
    return profit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 我们的目的是找到n天之内进行最多k次交易的最大利润, 那么我们给出以下定义:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;: j天之内进行最多i次交易的最大利润&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们发现dp[i][j]可能与价格prices[j]有关, 也可能无关.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果无关, 容易知道&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;等于&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j-1]&lt;/code&gt; (最优子结构性质)&lt;/li&gt;
  &lt;li&gt;如果有关, &lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;是如何影响&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;的取值的呢? 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;能够影响&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j]&lt;/code&gt;, 那么就只能是&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;这个价格卖出获得更大的利润. 所以就需要记录一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;holds: 买进状态下, 持有的最大利润&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分析到这里就会发现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dp[i][j] = max( dp[i][j-1], holds+prices[j] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么&lt;code class=&quot;highlighter-rouge&quot;&gt;holds&lt;/code&gt;是如何受&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;的影响的呢? 因为holds表示买进状态, 所以如果&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;能够影响&lt;code class=&quot;highlighter-rouge&quot;&gt;holds&lt;/code&gt;, 那么就只能是买进&lt;code class=&quot;highlighter-rouge&quot;&gt;prices[j]&lt;/code&gt;, 而且买进之前的最大利润是&lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1][j-1]&lt;/code&gt;, 所以&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;holds = max( holds, dp[i-1][j-1]-prices[j] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(kn), 空间复杂度是O(kn)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;besttimetobuyandsellstock-iii&quot;&gt;BestTimeToBuyAndSellStock III&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

  &lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most two transactions.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;p&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int maxProfitDP( int[] prices ) {
    int len = prices.length;
    int k = 2;
    // 如果交易次数超过最大交易次数, 获取最大利润
    if( k &amp;gt; len/2 ) return quickSolve( prices );

    // dp[i][j]: 在第j天之前交易i次可以获得的最大利润
    int[][] dp = new int[k+1][len];
    for( int i = 1; i &amp;lt;= k; ++i ) {
        // holds: 买进状态下, 目前持有的最大利润
        int holds = -prices[0];
        for( int j = 1; j &amp;lt; len; ++j ) {
            dp[i][j] = Math.max( dp[i][j-1], holds+prices[j] );
            holds = Math.max( holds, dp[i-1][j-1]-prices[j] );
        }
    }
    return dp[k][len-1];
}

private static int quickSolve( int[] prices ) {
    int profit = 0;
    for( int i = 1; i &amp;lt; prices.length; ++i )
        if( prices[i] &amp;gt; prices[i-1] )
            profit += prices[i] - prices[i-1];
    return profit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 这是上一题中k=2的特殊情况&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(n)&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/01/leetcode-BestTimeToBuyAndSellStock(II)(III)(IV)/</link>
        <guid isPermaLink="true">/2016/04/01/leetcode-BestTimeToBuyAndSellStock(II)(III)(IV)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>动态规划原理学习笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;动态规划定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;动态规划原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;动态规划的基本要素&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;最优子结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;重叠子问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;动态规划的变形&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;备忘录方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;动态规划定义&lt;/h3&gt;

&lt;p&gt;动态规划算法是一种&lt;code class=&quot;highlighter-rouge&quot;&gt;计算算法&lt;/code&gt;, 可以在多项式时间计算出问题的解&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;动态规划原理&lt;/h3&gt;

&lt;p&gt;动态规划的计算原理是&lt;code class=&quot;highlighter-rouge&quot;&gt;问题分解&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原理: 动态规划算法与分治法类似, 基本思想是&lt;code class=&quot;highlighter-rouge&quot;&gt;将待求解问题分解为若干个子问题, 先求解子问题, 然后从子问题的解得到原始问题的解&lt;/code&gt;. 与分治法不同的是, 动态规划划分出来的&lt;code class=&quot;highlighter-rouge&quot;&gt;子问题往往不是相互独立的&lt;/code&gt;. 若用分治法来解这类问题, 则分解得到的子问题数目太多, 以至于需要耗费指数时间解决问题, 而子问题的数目常常只有多项式量级. 在用分治法求解时, 有些子问题被重复计算了很多次. 如果我们能够保存已解决的子问题答案, 在需要的时候查一下, 这样就可以避免大量的重复计算, 从而得到多项式时间算法. 为了达到此目的, 可以用一个表来记录已解决的子问题答案. 不管该子问题以后是否被用到, 只要它被计算过, 就将其结果填入表中. 这就是动态规划的基本思想.&lt;/p&gt;

&lt;p&gt;动态规划算法适用于解&lt;code class=&quot;highlighter-rouge&quot;&gt;最优化问题&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法的步骤如下:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;找出最优解的性质, 并刻画其结构特征&lt;/li&gt;
    &lt;li&gt;递归定义最优值&lt;/li&gt;
    &lt;li&gt;以自底向顶的方式计算出最优值&lt;/li&gt;
    &lt;li&gt;根据计算最优值时得到的信息, 构造最优解&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;动态规划的基本要素&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;最优子结构&lt;/h4&gt;

&lt;p&gt;设计动态规划算法的第一步通常是刻画最优解的结构. &lt;code class=&quot;highlighter-rouge&quot;&gt;当问题的最优解包含了其子问题的最优解是, 称该问题具有最优子结构性质&lt;/code&gt;. 问题具有最优子结构性质提供了可用动态规划算法求解的重要线索.&lt;/p&gt;

&lt;p&gt;分析问题的最优子结构性质时, 所用的方法具有普遍性, 就是&lt;code class=&quot;highlighter-rouge&quot;&gt;反证法&lt;/code&gt;. 首先假设问题的最优解导出的子问题的解不是最优的, 然后再分析说明在这个假设下, 可以构造出比原有问题最优解更好的解, 从而导致矛盾.&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;重叠子问题&lt;/h4&gt;

&lt;p&gt;在用递归算法自顶向底解问题时, 每次产生的子问题并不总是新问题, 有些子问题被反复计算多次. 动态规划算法正是利用了这种子问题的重叠性质, 对每一个子问题只解一次, 而后将其解保存在一个表格中, 当需要再次解此子问题时, 只是以简单地查询一下. 通常, 不同的子问题个数随问题的大小呈多项式增长. 因此, 用动态规划算法通常只需要多项式时间, 从而获得较高的解题效率.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;动态规划的变形&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;备忘录方法&lt;/h4&gt;

&lt;p&gt;备忘录方法用表格保存已解决子问题的答案, 在下次需要解此子问题时, 只要简单查看该子问题的答案, 而不必重新计算. 与动态规划算法不同的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;备忘录方法的递归方式是自顶向底的, 而动态规划算法则是自底向顶的&lt;/code&gt;. 因此, 备忘录方法的控制结构与动态规划的控制结构相同, 区别在于备忘录方法为每个解过的子问题建立备忘录以备查询.&lt;/p&gt;

&lt;p&gt;备忘录方法为每个子问题建立一个记录项, 初始化时, 该记录项存入一个特殊值, 表示该子问题尚未求解. 在求解过程中, 对每个待求的子问题, 首先查看相应的记录项. 如果存储的是特殊值, 则表示该子问题是第一次遇到, 此时计算该子问题的解并保存进记录项. 如果存储的不是特殊值, 则表示该子问题已经被计算过, 此时直接查询返回即可.&lt;/p&gt;

&lt;p&gt;一般来讲, 当一个问题的所有子问题都至少需要解一次时, 用动态规划算法比备忘录方法好. 此时动态规划算法没有任何多余的计算. 同时, 对于许多问题, 常可利用其规则的表格存取方式, 减少动态规划算法的计算时间和空间需求. 当子问题空间中的部分字问题可不必求解时, 用备忘录方法则较有利, 因为从其控制结构可以看出, 该方法只解那些确实需要求解的子问题.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/01/algorithm-dynamic-programming/</link>
        <guid isPermaLink="true">/2016/04/01/algorithm-dynamic-programming/</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>Combinations</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinations&quot; id=&quot;markdown-toc-combinations&quot;&gt;Combinations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinations&quot;&gt;Combinations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombine( n, 1, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}
public static void helperCombine( 
        int n, int t, int k, List&amp;lt;Integer&amp;gt; tmpRes, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res ) {
    // 约束条件
    if( t &amp;gt; n ) {
        return;
    }
    // 不选取当前值
    helperCombine( n, t+1, k, tmpRes, res );
    
    // 选取当前值
    tmpRes.add( t );
    if( k-1 == 0 ) {    // 获得一个结果
        res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
    } else {            // 进入下一层
        helperCombine( n, t+1, k-1, tmpRes, res );
    }
    tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于[1…n]中的每一个元素, 可取可不取&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;放在方法头部更容易理解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-Combinations/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-Combinations/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>CombinationSum(II)(III)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum&quot; id=&quot;markdown-toc-combinationsum&quot;&gt;CombinationSum&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum-ii&quot; id=&quot;markdown-toc-combinationsum-ii&quot;&gt;CombinationSum II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#combinationsum-iii&quot; id=&quot;markdown-toc-combinationsum-iii&quot;&gt;CombinationSum III&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;combinationsum&quot;&gt;CombinationSum&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;

  &lt;p&gt;The same repeated number may be chosen from C unlimited number of times.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
    &lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, &amp;gt; a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example, given candidate set 2,3,6,7 and target 7,
A solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[7]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 2, 3]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum( 
        int[] candidates, int target ) {
    // 排序, 后面才可以进行剪枝
    Arrays.sort( candidates );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombinationSum2( 
            candidates, target, 0, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperCombinationSum2(
        int[] candidates, int target, int t, List&amp;lt;Integer&amp;gt; tmpRes, 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
    // 约束条件
    if( t == candidates.length ) {
        return;
    }
    // 剪枝
    if( candidates[t] &amp;gt; target ) {
        return;
    }
    
    // 遍历解空间
    int i = 0;
    for( ; i*candidates[t] &amp;lt;= target; ++i ) {
        if( i != 0 ) tmpRes.add( candidates[t] );
        if( i*candidates[t] == target ) {
            res.add( new ArrayList&amp;lt;Integer&amp;gt;( tmpRes) );
        } else {
            helperCombinationSum2( candidates, 
            	target-i*candidates[t], t+1, tmpRes, res );
        }
    }
    while( i-- &amp;gt; 1 )
        tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 对于candidates数组中的每一个值, 可以无限重复取, 但是实际上只要取到一定程度就就可以结束了, 结束条件: i*candidates[t] &amp;gt; target, 也就是取[0…i]的情况, [i+1…∞]不取.&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;combinationsum-ii&quot;&gt;CombinationSum II&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;

  &lt;p&gt;Each number in C may only be used once in the combination.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
    &lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example, given candidate set 10,1,2,7,6,1,5 and target 8,&lt;/p&gt;

  &lt;p&gt;A solution set is:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 7]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 5]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 6]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 1, 6]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2( 
		int[] candidates, int target ) {
	// 排序, 后面才可以进行剪枝
	Arrays.sort( candidates );
	List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
	helperCombinationSum( 
			candidates, target, 0, new ArrayList&amp;lt;Integer&amp;gt;(), res );
	return res;
}

private static void helperCombinationSum(
		int[] candidates, int target, int t, List&amp;lt;Integer&amp;gt; tmpRes, 
		List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
	if( t == candidates.length ) {
		return;
	}
	// 剪枝
	if( candidates[t] &amp;gt; target ) {
		return;
	}
	
	// 统计重复元素个数
	int repeatCount = 0;
	while( repeatCount+t &amp;lt; candidates.length &amp;amp;&amp;amp; 
			candidates[t] == candidates[t+repeatCount])
		++repeatCount;
	
	// 遍历解空间
	int i = 0;
	for( ; i &amp;lt;= repeatCount &amp;amp;&amp;amp; i*candidates[t] &amp;lt;= target; ++i ) {
		if( i != 0 ) tmpRes.add( candidates[t] );
		if( i*candidates[t] == target ) {
			res.add( new ArrayList&amp;lt;Integer&amp;gt;( tmpRes) );
		} else {
			helperCombinationSum( candidates, 
			    target-i*candidates[t], t+repeatCount, tmpRes, res );
		}
	}
	while( i-- &amp;gt; 1 )
		tmpRes.remove( tmpRes.size()-1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 同CombinationSum一样. 不一样的地方: CombinationSum中的每个元素取[0,∞]个, 这里每个元素取[0…R]个, R表示元素的重复个数, 所以代码里面就多了限制条件: &lt;code class=&quot;highlighter-rouge&quot;&gt;i &amp;lt;= repeatCount&lt;/code&gt; 而且进入下一层要跨越重复元素: &lt;code class=&quot;highlighter-rouge&quot;&gt;t+repeatCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型, 思考新问题中&lt;code class=&quot;highlighter-rouge&quot;&gt;影响因素&lt;/code&gt;对结果产生的影响, 并且从原有模型中调整得到解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;combinationsum-iii&quot;&gt;CombinationSum III&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;

  &lt;p&gt;Ensure that numbers within the set are sorted in ascending order.&lt;/p&gt;

  &lt;p&gt;Example 1:&lt;/p&gt;

  &lt;p&gt;Input: k = 3, n = 7&lt;/p&gt;

  &lt;p&gt;Output:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,2,4]]&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;Example 2:&lt;/p&gt;

  &lt;p&gt;Input: k = 3, n = 9&lt;/p&gt;

  &lt;p&gt;Output:&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,2,6], [1,3,5], [2,3,4]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-6&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3( int n, int k ) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    helperCombinationSum3( n, k, new ArrayList&amp;lt;Integer&amp;gt;(), res );
    return res;
}

private static void helperCombinationSum3( int n, int k, List&amp;lt;Integer&amp;gt; tmpRes, 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res) {
    // 约束条件
    if( k &amp;lt;= 0 || n &amp;lt;= 0 ) {
        return;
    }
    
    // 保证结果子集中不可能出现重复元素
    int i = tmpRes.size()==0 ? 1 : tmpRes.get(tmpRes.size()-1)+1;
    for( ; i &amp;lt;= 9; ++i ) {
        tmpRes.add( i );
        if( n-i == 0 &amp;amp;&amp;amp; k-1 == 0 ) {
            res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
        } else {
            helperCombinationSum3( n-i, k-1, tmpRes, res );
        }
        tmpRes.remove( tmpRes.size()-1 );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: &lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;. 本质上跟上面两题都是一样的. 不同的地方就是: &lt;code class=&quot;highlighter-rouge&quot;&gt;约束条件&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;解空间的遍历方式&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;时空复杂度: 时间复杂度是&lt;code class=&quot;highlighter-rouge&quot;&gt;不确定&lt;/code&gt;, 空间复杂度是O(n): 递归的空间, 排除构造出来的结果集&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/31/leetcode-CombinationSum(II)(III)/</link>
        <guid isPermaLink="true">/2016/03/31/leetcode-CombinationSum(II)(III)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>进程的查看</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ps&quot; id=&quot;markdown-toc-ps&quot;&gt;ps指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-1&quot; id=&quot;markdown-toc-ps-1&quot;&gt;ps参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ps-2&quot; id=&quot;markdown-toc-ps-2&quot;&gt;ps使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#t-o-p&quot; id=&quot;markdown-toc-t-o-p&quot;&gt;t-o-p指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-1&quot; id=&quot;markdown-toc-t-o-p-1&quot;&gt;t-o-p参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-2&quot; id=&quot;markdown-toc-t-o-p-2&quot;&gt;t-o-p程序指令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#t-o-p-3&quot; id=&quot;markdown-toc-t-o-p-3&quot;&gt;t-o-p使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pstree&quot; id=&quot;markdown-toc-pstree&quot;&gt;pstree指令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-1&quot; id=&quot;markdown-toc-pstree-1&quot;&gt;pstree参数说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pstree-2&quot; id=&quot;markdown-toc-pstree-2&quot;&gt;pstree使用实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps&quot;&gt;ps指令&lt;/h3&gt;

&lt;h4 id=&quot;ps-1&quot;&gt;ps参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;显示所有的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;排除与终端有关的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;指定特定用户的进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;显示更完整的信息, 与a参数一起使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;长格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;工作格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;完整格式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;ps-2&quot;&gt;ps使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看与bash相关的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps -l
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-l.png&quot; alt=&quot;ps-l&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;F&lt;/td&gt;
          &lt;td&gt;4表示进程权限为root, 1表示进程只能fork, 不能执行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;S&lt;/td&gt;
          &lt;td&gt;进程的STATE, R-&amp;gt;运行, S-&amp;gt;睡眠, D-&amp;gt;阻塞, T-&amp;gt;停止, Z-&amp;gt;僵尸&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;UID&lt;/td&gt;
          &lt;td&gt;用户ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PPID&lt;/td&gt;
          &lt;td&gt;父进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;C&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PRI/NI&lt;/td&gt;
          &lt;td&gt;进程优先级相关, 越小优先级越高&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ADDR&lt;/td&gt;
          &lt;td&gt;进程内存地址&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SZ&lt;/td&gt;
          &lt;td&gt;消耗的内存&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;WCHAN&lt;/td&gt;
          &lt;td&gt;运行状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;CMD&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统所有的进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-aux.png&quot; alt=&quot;ps-aux&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VSZ&lt;/td&gt;
          &lt;td&gt;虚拟内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RSS&lt;/td&gt;
          &lt;td&gt;内存占用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TTY&lt;/td&gt;
          &lt;td&gt;终端接口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;STAT&lt;/td&gt;
          &lt;td&gt;进程状态&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;START&lt;/td&gt;
          &lt;td&gt;进程启动时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME&lt;/td&gt;
          &lt;td&gt;进程运行累计时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看系统某进程&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ps aux | egrep &#39;xrgsu&#39;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-ps-ps-egrep.png&quot; alt=&quot;ps-egrep&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;t-o-p&quot;&gt;t-o-p指令&lt;/h3&gt;

&lt;h4 id=&quot;t-o-p-1&quot;&gt;t-o-p参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;更新频率, 以秒为单位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b&lt;/td&gt;
      &lt;td&gt;批处理, 通常配合数据流重定向&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;与-b配合, 指定批处理总次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;检测指定进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-2&quot;&gt;t-o-p程序指令&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;查看top程序指令帮助&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;按照CPU使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;按照内存使用率大小排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;按照PID排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;按照CPU运行总时长排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;kill进程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;重新给进程nice值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;q&lt;/td&gt;
      &lt;td&gt;退出top&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;t-o-p-3&quot;&gt;t-o-p使用实例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每隔2秒更新一次资源状态&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -d 2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/linux/linux-top-d2.png&quot; alt=&quot;top-d2&quot; /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;PID&lt;/td&gt;
          &lt;td&gt;进程ID&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;USER&lt;/td&gt;
          &lt;td&gt;用户&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;PR/NI&lt;/td&gt;
          &lt;td&gt;优先级&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;VIRT&lt;/td&gt;
          &lt;td&gt;虚拟内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RES&lt;/td&gt;
          &lt;td&gt;内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SHR&lt;/td&gt;
          &lt;td&gt;共享内存使用量&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%CPU&lt;/td&gt;
          &lt;td&gt;CPU使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;%MEM&lt;/td&gt;
          &lt;td&gt;内存使用率&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TIME+&lt;/td&gt;
          &lt;td&gt;CPU使用累积时间&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMAND&lt;/td&gt;
          &lt;td&gt;进程指令&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把资源状态结果输出到文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  top -b -n 2 &amp;gt; /tmp/top.txt
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pstree&quot;&gt;pstree指令&lt;/h3&gt;

&lt;h4 id=&quot;pstree-1&quot;&gt;pstree参数说明&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;以ASCII字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-U&lt;/td&gt;
      &lt;td&gt;以UTF8字符显示进程树&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;显示进程所属用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;显示进程PID&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;pstree-2&quot;&gt;pstree使用实例&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pstree -Uup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/linux/linux-pstree-Uup.png&quot; alt=&quot;pstree-Uup&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/linux-process-check/</link>
        <guid isPermaLink="true">/2016/03/30/linux-process-check/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Permutations(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations&quot; id=&quot;markdown-toc-permutations&quot;&gt;Permutations&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#permutations-ii&quot; id=&quot;markdown-toc-permutations-ii&quot;&gt;Permutations II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;permutations&quot;&gt;Permutations&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,2,3] have the following permutations:&lt;/p&gt;

  &lt;p&gt;[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute( int[] nums ) {
    helperPermute( nums, 0 );
    return res;
}
private static void helperPermute( int[] nums, int t ) {
    if( t == nums.length ) {
        // 构造一个结果
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        
        // 加入结果集
        res.add( tmpRes );
    } else {
        for( int i = t; i &amp;lt; nums.length; ++i ) {
            swap( nums, t, i);
            helperPermute( nums, t+1 );
            swap( nums, t, i);
        }
    }
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个集合的全排列, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;排列树&lt;/code&gt;问题.&lt;/p&gt;

&lt;p&gt;代码可以这样理解, 集合S的全排列由以下的结果组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S[1]+全排列( S[2…n] )&lt;/li&gt;
  &lt;li&gt;S[2]+全排列( S[1, 3…n] )&lt;/li&gt;
  &lt;li&gt;S[3]+全排列( S[2, 1, 4…n] )&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;S[n]+全排列( S[1…n-1] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是把S的中每一个元素都提取到第一位, 剩下的元素做全排列&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 为什么要swap2次? 因为我们要保证在处理完一次结果之后, 要恢复数组的原始状态, 这样下一次处理的时候才能正确把下一个元素交换到第一个位置来.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的全排列&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个处理过程是迭代形式的, 而且迭代过程有严格的状态要求, 那么就十分需要注意子处理过程所带来的影响.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;permutations-ii&quot;&gt;Permutations II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

  &lt;p&gt;For example,&lt;/p&gt;

  &lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

  &lt;p&gt;[1,1,2], [1,2,1], and [2,1,1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique( int[] nums ) {
    Arrays.sort( nums );
    helperPermuteUnique( nums, 0, nums.length-1 );
    return res;
}
private static void helperPermuteUnique( int[] nums, int i, int j ) {
    if( i == j ) {
        List&amp;lt;Integer&amp;gt; tmpRes = new ArrayList&amp;lt;&amp;gt;(nums.length);
        for( int num : nums ) tmpRes.add( num );
        res.add( tmpRes );
    } 
    for( int k = i; k &amp;lt;= j; ++k ) {
        if( findSame(nums, i, k) ) continue;
        swap( nums, i, k );
        helperPermuteUnique( nums, i+1, j );
        swap( nums, i, k );
    }
}

private static boolean findSame( int[] nums, int i, int j ) {
    for( int k = i; k &amp;lt; j; ++k )
        if( nums[j] == nums[k] ) return true;
    return false;
}

private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 对于有重复元素集合的全排列, 可以用上面无重复元素的全排列来解决, 区别就是我们在这个基础上还要排除一些重复的全排列, 那么我们需要思考的问题是: 按照无重复元素的全排列处理过程, 如何消除重复元素带来的影响? 我们知道全排列的一次处理过程就是把每一个元素都搬到第一个位置, 然后做剩余元素的全排列, 所以我们只需要判断当前元素跟前面的元素有没有重复, 有重复的话就是已经处理过的, 直接跳过.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;借助已有的处理模型去思考问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-permutations(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-permutations(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Next Permutation</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically &amp;gt; next greater permutation of numbers.&lt;/p&gt;

  &lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible &amp;gt; order (ie, sorted in ascending order).&lt;/p&gt;

  &lt;p&gt;The replacement must be in-place, do not allocate extra memory.&lt;/p&gt;

  &lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding &amp;gt; outputs are in the right-hand column.&lt;/p&gt;

  &lt;p&gt;1,2,3 → 1,3,2&lt;/p&gt;

  &lt;p&gt;3,2,1 → 1,2,3&lt;/p&gt;

  &lt;p&gt;1,1,5 → 1,5,1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void nextPermutation( int[] nums ) {

    // 从后往前找到第一个递增对 [i, i+1]
    int i = nums.length-2;
    for( ; i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i+1]; --i );

    // 已经不存在递增对, 所有排列已经列举完了, 这里重新开始
    if( i &amp;lt; 0 ) {
        reverse( nums, 0, nums.length-1 );
        return;
    }

    // 从后往前找到第一个 [j] &amp;gt; [i]
    int j = nums.length-1;
    for( ; j &amp;gt; i &amp;amp;&amp;amp; nums[j] &amp;lt;= nums[i]; --j );

    // 构造下一个全排列
    swap( nums, i, j );
    i = i + 1;
    j = nums.length-1;
    reverse( nums, i, j );
}
private static void swap( int[] nums, int i, int j ) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
private static void reverse( int[] nums, int i, int j ) {
    while( i &amp;lt; j ) {
        swap( nums, i++, j-- );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 求一个排列的下一个排列, 从数值上看, 就是找到下一个值, 使得下一个值&lt;code class=&quot;highlighter-rouge&quot;&gt;比当前值大&lt;/code&gt;并且要&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;. 所以我们可以从数值的低位部分入手, 因为改变低位对数值大小的影响最小, 也就满足了&lt;code class=&quot;highlighter-rouge&quot;&gt;最接近&lt;/code&gt;这个条件. 现在考虑一个例子:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, … , A&lt;sub&gt;K&lt;/sub&gt;, A&lt;sub&gt;K+1&lt;/sub&gt;, …, A&lt;sub&gt;N&lt;/sub&gt;]&lt;/li&gt;
  &lt;li&gt;A&lt;sub&gt;K+1&lt;/sub&gt; &amp;gt; … &amp;gt; A&lt;sub&gt;N&lt;/sub&gt; ( 1 &amp;lt; K &amp;lt; N, 也就是[K+1…N]递减 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于[K+1…N]这部分是递减的, 那么在这部分做修改是不可能构造出一个比当前值还大的值, 所以就要第[K]位加进来, 也就是对[K…N]这部分做修改, 那么该如何改呢?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在[K+1…N]中找一个刚好比[K]大的值, 与[K]交换, 才能构造出一个比当前值大的值, 所以就可以在[K+1…N]中由后往前找合适的值([K+1…N]是递减的, 所以由后往前找)&lt;/li&gt;
  &lt;li&gt;找到合适的值之后与[K]交换, 交换之后[K+1…N]还是递减的&lt;/li&gt;
  &lt;li&gt;修改[K+1…N]这部分变为最小值, 因为[K+1…N]是递减的, 翻转以下就可以了&lt;/li&gt;
  &lt;li&gt;得到下一个全排列的值&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 求下一个排列的问题可以转化为数值的问题, 然后又要想到数值的变化影响因素中, 低位的影响是最小的, 所以思考点要转移到如何修改低位部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n), 空间复杂度是O(1)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;专注问题的思考点, 并且不断转换思考点, 直到问题清晰可解&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-next-permutation/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-next-permutation/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>NQueens(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#nqueens&quot; id=&quot;markdown-toc-nqueens&quot;&gt;NQueens&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nqueens-ii&quot; id=&quot;markdown-toc-nqueens-ii&quot;&gt;NQueens II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nqueens&quot;&gt;NQueens&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such &amp;gt; that no two queens attack each other.&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2012/03/8-queens.png&quot; alt=&quot;8-Queens&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;

  &lt;p&gt;Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.
For example,
There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueensRecursion( int n ) {
      List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      // 创建棋盘: board[i]表示第i行第board[i]列
      int[] board = new int[n];
      // 初始化棋盘, -1表示没有棋子
      Arrays.fill(board, -1);
      // 回溯查找解
      helperNQueens( 0, board, res );
      return res;
  }

  private static void helperNQueens(int t, int[] board, List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res) {
      if( t == board.length ) {
          res.add( newBoard(board) );
          return;
      }
      for( int i = 0; i &amp;lt; board.length; ++i ) {
          board[t] = i;
          if( constraints( board, t ) )
              helperNQueens( t+1, board, res );
      }
  }

  private static boolean constraints(int[] board, int t) {
      for( int i = 0; i &amp;lt; t; ++i ) {
          if( (board[i] == board[t]) ||
                  (t-i == board[t]-board[i] || t-i == board[i]-board[t]) )
              return false;
      }
      return true;
  }

  /*
   * 返回棋盘的表示形式, 类型为List&amp;lt;String&amp;gt;
   */
  private static List&amp;lt;String&amp;gt; newBoard(int[] board) {
      List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      int n = board.length;
      char[][] newBoard = new char[n][n];
      for( int i = 0; i &amp;lt; n; ++i )
          Arrays.fill(newBoard[i], &#39;.&#39;);
      for( int i = 0; i &amp;lt; n; ++i ) {
          newBoard[i][board[i]] = &#39;Q&#39;;
          StringBuilder sb = new StringBuilder();
          for( char c : newBoard[i] ) sb.append(c);
          res.add( sb.toString() );
      }
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考过程: N皇后问题属于经典的题目, 用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;来解决&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;疑难点: 难点主要有两个, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;棋盘的表示&lt;/code&gt;, 另一个是皇后之间的&lt;code class=&quot;highlighter-rouge&quot;&gt;冲突判断&lt;/code&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;棋盘的表示&lt;/code&gt;要建立在对问题约束条件的理解之上. 棋盘之中皇后之间不能处于同一行, 也不能处于同一列, 那么我们可以用一个数组board来表示这个棋盘.&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;数组下标表示棋盘中的行值&lt;/li&gt;
        &lt;li&gt;数组的值表示棋盘中的列值&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;冲突判断&lt;/code&gt;有3个条件:&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;皇后不能处于同一行: 不需要显示判断, 因为我们以行作为递归, 皇后不可能出现在同一行&lt;/li&gt;
        &lt;li&gt;皇后不能处于同一列: 根据 board[i] == board[j] 作为判断&lt;/li&gt;
        &lt;li&gt;皇后不能处于同一斜线: 根据 j-i == abs(board[j]-board[i]) (j&amp;gt;i)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;斜线的判断可能比较难以理解: 意思是行值差与列值差相等表示皇后在同一斜线上.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时空复杂度: 时间复杂度是O(n!), 空间复杂度是O(n): 递归的空间, 排除构造出来的棋盘&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;善于观察题目的限制条件, 从而构造出合适的数据结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; solveNQueensIteration( int n ) {
      List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
      // 创建棋盘: board[i]表示第i行第board[i]列
      int[] board = new int[n];

      // 初始化第0行的状态
      board[0] = -1;
      // t表示目前处于第t行
      int t = 0;
      while( t &amp;gt;= 0 ) {
          // 查找第t行皇后的存放位置
          ++board[t];
          while( board[t] &amp;lt; n &amp;amp;&amp;amp; !constraints( board, t ) ) ++board[t];

          // 找到第t行皇后的存放位置就进入下一行
          if( board[t] &amp;lt; n ) {
              if( t == n-1 ) {
                  res.add( newBoard(board) );
              } else {
                  ++t;
                  board[t] = -1;
              }
          } else {
              --t;
          }
      }
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;nqueens-ii&quot;&gt;NQueens II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;

  &lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.
&lt;img src=&quot;http://articles.leetcode.com/wp-content/uploads/2012/03/8-queens.png&quot; alt=&quot;8-Queens&quot; /&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;p&gt;该题目的算法与上一道题的一模一样, 只需要在相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;递归版本&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;迭代版本&lt;/code&gt;中找到可行解的时候统计数量即可&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/30/leetcode-NQueens(II)/</link>
        <guid isPermaLink="true">/2016/03/30/leetcode-NQueens(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
      <item>
        <title>Subsets(II)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets&quot; id=&quot;markdown-toc-subsets&quot;&gt;Subsets&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#subsets-ii&quot; id=&quot;markdown-toc-subsets-ii&quot;&gt;Subsets II&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;题目描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;解法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subsets&quot;&gt;Subsets&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,3], a solution is:
    [
      [3],
      [1],
      [2],
      [1,2,3],
      [1,3],
      [2,3],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsRecursion( int[] nums ) {
      Arrays.sort( nums );
      helperRecursion( nums, 0, new ArrayList&amp;lt;Integer&amp;gt;() );
      return res;
  }
  private static void helperRecursion( int[] nums, int t, List&amp;lt;Integer&amp;gt; tmpRes ) {
      // 获得一个子集
      if( t == nums.length ) {
          res.add( new ArrayList&amp;lt;Integer&amp;gt;(tmpRes) );
          return;
      }
      // 不选择当前深度的节点
      helperRecursion( nums, t+1, tmpRes );

      // 选择当前深度的节点
      tmpRes.add( nums[t] );
      helperRecursion( nums, t+1, tmpRes );
      tmpRes.remove( tmpRes.size()-1 );
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 求一个集合的所有子集, 这个问题可以归类为&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;子集树&lt;/code&gt;问题, 而且这棵树是一棵完全二叉树, 利用&lt;code class=&quot;highlighter-rouge&quot;&gt;回溯法&lt;/code&gt;中的递归写法可以很容易的写出代码.&lt;/p&gt;

    &lt;p&gt;处理过程: 利用一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;表示当前树的深度, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;深度的时候, 有两种选择, 一种是不选择当前深度的节点并且进入下一层, 另一种是选择当前深度的节点并且进入下一层. 其终止条件就是到达叶子节点.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度是O(2^n), 空间复杂度是O(n): 递归的空间, 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;迭代方式&lt;/p&gt;

    &lt;p&gt;代码如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetIteration( int[] nums ) {
      Arrays.sort( nums );
      List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        
      // 初始状态: 结果集中包含了子集: 空集
      res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
        
      // 构造过程: 动态生成每一个子集并且加入结果集
      for( int i = 0; i &amp;lt; nums.length; ++i ) {
          int subsetCount = res.size();
          for( int j = 0; j &amp;lt; subsetCount; ++j ) {
              List&amp;lt;Integer&amp;gt; newSubset = new ArrayList&amp;lt;&amp;gt;( res.get(j) );
              newSubset.add( nums[i] );
              res.add( newSubset );
          }
      }
        
      // 结束状态: 返回结果集
      return res;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;思考过程: 在思考问题解之前, 可以先思考另外一个问题: 对结果集产生影响的基本因素是什么? 基本因素就是数组中的元素. 再思考一个问题: 基本因素是如何影响结果集的? 当原本数组加入一个新的元素的时候, 由于元素在子集中可选可不选, 不选的话不会对原本的结果集产生影响, 选择的话原本的结果集会多添加一些新子集, 而且这些新子集=旧子集+新元素&lt;/p&gt;

    &lt;p&gt;处理过程: 首先, 对于任何的数组, 其结果集中一定有一个空集; 之后对每一个元素, 产生一些新子集: 新子集=旧子集+新元素, 并且把新子集加入结果集中; 最后返回结果集.&lt;/p&gt;

    &lt;p&gt;时空复杂度: 时间复杂度O(2^n), 空间复杂度O(1): 排除构造出来的子集空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于有处理模型的问题, 我们很容易想到解决方案; 但是有时候我们并不知道处理模型是什么, 我们应该从小方面入手, 思考问题的基本因素, 从基本因素展开分析, 从而构造出一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;subsets-ii&quot;&gt;Subsets II&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;题目描述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;

  &lt;p&gt;Note:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Elements in a subset must be in non-descending order.&lt;/li&gt;
    &lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;For example,
If nums = [1,2,2], a solution is:
    [
      [2],
      [1],
      [1,2,2],
      [2,2],
      [1,2],
      []
    ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsIteration( int[] nums ) {
    Arrays.sort( nums );
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
    
    // 初始状态: 结果集中包含了子集: 空集
    res.add( new ArrayList&amp;lt;Integer&amp;gt;() );
    
    // 构造过程: 对每一个元素构造出新子集并加入结果集
    for( int i = 0; i &amp;lt; nums.length; ) {
        // 统计重复个数
        int repeatNum = 0;
        while( i+repeatNum &amp;lt; nums.length &amp;amp;&amp;amp;
                nums[i] == nums[repeatNum+i] ) ++repeatNum;
        // 构造子集
        int subsetCount = res.size();
        for( int j = 0; j &amp;lt; subsetCount; ++j ) {
            List&amp;lt;Integer&amp;gt; subset = new ArrayList&amp;lt;Integer&amp;gt;( res.get(j) );
            for( int k = 0; k &amp;lt; repeatNum; ++k ) {
                subset.add( nums[i] );
                res.add( new ArrayList&amp;lt;Integer&amp;gt;( subset ) );
            }
        }
        i += repeatNum;
    }
    
    // 结束状态: 返回结果集
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;思考过程: 其基本思考过程同上面的Subsets迭代方式差不多, 不同点在于出现了重复元素, 那么还是一样, 我们思考重复元素对原始结果集的影响是什么? 思考这样一个例子[ 1, 2, 2 ], 当处理完元素[1]的时候, 我们得到的结果集是{ {}, {1} }, 接下来对于重复元素[2], 我们可以构造出来的新子集=旧子集+(1或2)个[2], 也就是说, 对于重复元素, 我们可以选择1-n个重复元素加入旧子集形成新子集, 对于重复元素的解决方案就出来了, 最后可以得到上面的代码&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;还是一样, 对于一个新的问题, 我们应该从基本的角度去思考, 从而展开到一个问题的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/29/leetcode-subsets(II)/</link>
        <guid isPermaLink="true">/2016/03/29/leetcode-subsets(II)/</guid>
        
        
        <category>Leetcode</category>
        
      </item>
    
  </channel>
</rss>
