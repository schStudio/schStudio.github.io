---
layout: post
title: "HTTP协议学习笔记"
categories: 计算机网络
---

* content
{:toc}

### 协议概述

设计HTTP的最初目的是为了**提供一种发布和接受HTML页面的方法**, 而HTML页面是通过统一资源定位符URI来标识.

**HTTP是一个客户端终端(用户)和服务器端(网站)请求和应答的标准.**

通过Web浏览器/网络爬虫/其他工具, 客户端可以发起一个HTTP请求到服务器上指定的端口(默认端口80), 请求的内容可以是HTML页面或图像等文件. 服务器端就是存储HTML页面或图片文件的地方, 所以服务器端对客户端的请求做出对应的应答, 发送对应的内容给客户端.在通信过程中, 客户端和服务器端中间可能存在着多个"中间层", 例如代理服务器/网关/隧道.

HTTP协议并没有明确规定要使用TCP协议作为它的传输层. 事实上HTTP可以在任何互联网协议上, 或是其它网络上实现. 但是HTTP协议假设下层提供可靠的传输服务. 因此, 任何能够保证可靠传输的协议都可以被HTTP协议使用.

客户端和服务器端的通信过程大致如下:

有HTTP客户端发送一个请求, 创建一个到服务器端指定端口的TCP连接. HTTP服务器则监听指定的端口, 一旦接收到请求, 服务器就会给客户端返回一个状态, 例如`"HTTP /1.1 200 OK"`, 以及返回的内容, 如请求的文件/错误消息/其它信息等.

- - -

### 请求信息

请求信息的格式模板如下:

    请求行<CR><LF>
    请求头<CR><LF>
    <CR><LF>
    其他消息体

- - -

### 请求方法

`HTTP/1.1`协议中共定义了8种方法(也叫"动作")来以不同方式操作指定的资源:

| 请求方法 | 说明 |
|--------|--------|
|`OPTIONS`|请求资源所支持的HTTP请求方法|
|`HEAD`|与GET方法一样, 但是服务器不传回内容, 只传回元信息|
|`GET`|请求资源内容|
|`POST`|请求提交数据资源, 例如提交表单和上传文件|
|`PUT`|向自定资源上传其最新内容|
|`DELETE`|请求服务器删除资源|
|`TRACE`|回显服务器受到的请求, 主要用于测试|
|`CONNECT`|预留给能够将连接改为管道方式的代理服务器, 例如SSL加密服务器|

> 注意:
> 
> * 方法名称是区分大小写的
> * HTTP服务器至少应该实现`GET`和`HEAD`方法, 其它方法都是可选的

* 当指定资源不支持所请求的方法时, 服务器返回`状态码405`(Method Not Allowed)
* 当指定资源不认识所请求的方法时, 服务器返回`状态码501`(Not Implemented)

- - -

### HTTPS

HTTPS的主要思想是在不安全的网络上创建一个安全信道, 并可使用适当的加密包和证书机制, 对窃听和中间人攻击提供合理的防护.

目前有两种方法来创建HTTPS连接:

* `HTTPS URI`
* `HTTP/1.1`请求头

由于浏览器对后者几乎没有任何支持, 因此`HTTPS URI`是创建HTTPS连接的主要手段.

- - -

### 版本

| 版本号 | 说明 |
|--------|--------|
|`0.9`|已过时, 只接受`GET`请求, 不支持请求头和`POST`方法|
|`1.0`|第一个在通讯中指定版本号的HTTP协议版本, 至今仍被广泛使用, 特别是代理服务器中|
|`1.1`|**持久连接**被默认采用, 并很好配合代理服务器工作, 还支持**管道方式**在同时发送多个请求, 以便降低线路负载, 提高传输速度|
|`2`|**异步连接复用, 头压缩, 请求反馈管线化**并保留与1.1的完全语义兼容|

`HTTP/1.1`相较于`HTTP/1.0`的主要区别是:

* 缓存处理
* 带宽优化及网络连接的使用
* 错误通知的管理
* 消息在网络中的发送
* 互联网地址的维护
* 安全性及完整性

- - -

### 状态码

所有的HTTP响应的第一行都是**状态行**, 格式如下:

	HTTP版本号 3位数字组成的状态码 状态码描述

| 状态码 | 说明 |
|--------|--------|
|`1xx`消息|请求已被服务器接收，继续处理|
|`2xx`成功|请求已成功被服务器接收、理解、并接受|
|`3xx`重定向|需要后续操作才能完成这一请求|
|`4xx`请求错误|请求含有词法错误或者无法被执行|
|`5xx`服务器错误|服务器在处理某个正确请求时发生错误|

- - -

### 持续连接

在`HTTP/0.9`和`HTTP/1.0`协议中并不支持持续连接, 也就是每个TCP连接只连接一个web对象, 在请求-响应结束后就会关闭. 我们知道TCP连接的建立与释放是需要消耗资源的, 如果有大量的请求, 那么TCP连接的建立与释放是很消耗资源的. 考虑实际情况, 大量请求里面是有很多请求来自于同一个客户端, 如果能够保持与客户端的TCP连接, 也就是持续连接, 那将会节省很多服务器资源.
持续连接保证一个TCP连接能够传送多个对象.

- - -

### 协议例子

* 客户端请求

        GET / HTTP/1.1
        Host: www.google.com

    > 注意: 
    > 
    > * 第一行指定方法、资源路径、协议版本
    > 
    > * 第二行是在`HTTP/1.1`里必带的一个header作用指定主机
    > 
    > * 末尾有一个空行

* 服务器响应

        HTTP/1.1 200 OK
        Content-Length: 3059
        Server: GWS/2.0
        Date: Sat, 11 Jan 2003 02:44:04 GMT
        Content-Type: text/html
        Cache-control: private
        Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
        X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com
        Connection: keep-alive

        ...Google主页的html文件...